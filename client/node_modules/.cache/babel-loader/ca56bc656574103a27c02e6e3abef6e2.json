{"ast":null,"code":"\"use strict\"; //High level idea:\n// 1. Use Clarkson's incremental construction to find convex hull\n// 2. Point location in triangulation by jump and walk\n\nmodule.exports = incrementalConvexHull;\n\nvar orient = require(\"robust-orientation\");\n\nvar compareCell = require(\"simplicial-complex\").compareCells;\n\nfunction compareInt(a, b) {\n  return a - b;\n}\n\nfunction Simplex(vertices, adjacent, boundary) {\n  this.vertices = vertices;\n  this.adjacent = adjacent;\n  this.boundary = boundary;\n  this.lastVisited = -1;\n}\n\nSimplex.prototype.flip = function () {\n  var t = this.vertices[0];\n  this.vertices[0] = this.vertices[1];\n  this.vertices[1] = t;\n  var u = this.adjacent[0];\n  this.adjacent[0] = this.adjacent[1];\n  this.adjacent[1] = u;\n};\n\nfunction GlueFacet(vertices, cell, index) {\n  this.vertices = vertices;\n  this.cell = cell;\n  this.index = index;\n}\n\nfunction compareGlue(a, b) {\n  return compareCell(a.vertices, b.vertices);\n}\n\nfunction bakeOrient(d) {\n  var code = [\"function orient(){var tuple=this.tuple;return test(\"];\n\n  for (var i = 0; i <= d; ++i) {\n    if (i > 0) {\n      code.push(\",\");\n    }\n\n    code.push(\"tuple[\", i, \"]\");\n  }\n\n  code.push(\")}return orient\");\n  var proc = new Function(\"test\", code.join(\"\"));\n  var test = orient[d + 1];\n\n  if (!test) {\n    test = orient;\n  }\n\n  return proc(test);\n}\n\nvar BAKED = [];\n\nfunction Triangulation(dimension, vertices, simplices) {\n  this.dimension = dimension;\n  this.vertices = vertices;\n  this.simplices = simplices;\n  this.interior = simplices.filter(function (c) {\n    return !c.boundary;\n  });\n  this.tuple = new Array(dimension + 1);\n\n  for (var i = 0; i <= dimension; ++i) {\n    this.tuple[i] = this.vertices[i];\n  }\n\n  var o = BAKED[dimension];\n\n  if (!o) {\n    o = BAKED[dimension] = bakeOrient(dimension);\n  }\n\n  this.orient = o;\n}\n\nvar proto = Triangulation.prototype; //Degenerate situation where we are on boundary, but coplanar to face\n\nproto.handleBoundaryDegeneracy = function (cell, point) {\n  var d = this.dimension;\n  var n = this.vertices.length - 1;\n  var tuple = this.tuple;\n  var verts = this.vertices; //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\n\n  var toVisit = [cell];\n  cell.lastVisited = -n;\n\n  while (toVisit.length > 0) {\n    cell = toVisit.pop();\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n\n    for (var i = 0; i <= d; ++i) {\n      var neighbor = cellAdj[i];\n\n      if (!neighbor.boundary || neighbor.lastVisited <= -n) {\n        continue;\n      }\n\n      var nv = neighbor.vertices;\n\n      for (var j = 0; j <= d; ++j) {\n        var vv = nv[j];\n\n        if (vv < 0) {\n          tuple[j] = point;\n        } else {\n          tuple[j] = verts[vv];\n        }\n      }\n\n      var o = this.orient();\n\n      if (o > 0) {\n        return neighbor;\n      }\n\n      neighbor.lastVisited = -n;\n\n      if (o === 0) {\n        toVisit.push(neighbor);\n      }\n    }\n  }\n\n  return null;\n};\n\nproto.walk = function (point, random) {\n  //Alias local properties\n  var n = this.vertices.length - 1;\n  var d = this.dimension;\n  var verts = this.vertices;\n  var tuple = this.tuple; //Compute initial jump cell\n\n  var initIndex = random ? this.interior.length * Math.random() | 0 : this.interior.length - 1;\n  var cell = this.interior[initIndex]; //Start walking\n\n  outerLoop: while (!cell.boundary) {\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n\n    for (var i = 0; i <= d; ++i) {\n      tuple[i] = verts[cellVerts[i]];\n    }\n\n    cell.lastVisited = n; //Find farthest adjacent cell\n\n    for (var i = 0; i <= d; ++i) {\n      var neighbor = cellAdj[i];\n\n      if (neighbor.lastVisited >= n) {\n        continue;\n      }\n\n      var prev = tuple[i];\n      tuple[i] = point;\n      var o = this.orient();\n      tuple[i] = prev;\n\n      if (o < 0) {\n        cell = neighbor;\n        continue outerLoop;\n      } else {\n        if (!neighbor.boundary) {\n          neighbor.lastVisited = n;\n        } else {\n          neighbor.lastVisited = -n;\n        }\n      }\n    }\n\n    return;\n  }\n\n  return cell;\n};\n\nproto.addPeaks = function (point, cell) {\n  var n = this.vertices.length - 1;\n  var d = this.dimension;\n  var verts = this.vertices;\n  var tuple = this.tuple;\n  var interior = this.interior;\n  var simplices = this.simplices; //Walking finished at boundary, time to add peaks\n\n  var tovisit = [cell]; //Stretch initial boundary cell into a peak\n\n  cell.lastVisited = n;\n  cell.vertices[cell.vertices.indexOf(-1)] = n;\n  cell.boundary = false;\n  interior.push(cell); //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\n\n  var glueFacets = []; //Do a traversal of the boundary walking outward from starting peak\n\n  while (tovisit.length > 0) {\n    //Pop off peak and walk over adjacent cells\n    var cell = tovisit.pop();\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n    var indexOfN = cellVerts.indexOf(n);\n\n    if (indexOfN < 0) {\n      continue;\n    }\n\n    for (var i = 0; i <= d; ++i) {\n      if (i === indexOfN) {\n        continue;\n      } //For each boundary neighbor of the cell\n\n\n      var neighbor = cellAdj[i];\n\n      if (!neighbor.boundary || neighbor.lastVisited >= n) {\n        continue;\n      }\n\n      var nv = neighbor.vertices; //Test if neighbor is a peak\n\n      if (neighbor.lastVisited !== -n) {\n        //Compute orientation of p relative to each boundary peak\n        var indexOfNeg1 = 0;\n\n        for (var j = 0; j <= d; ++j) {\n          if (nv[j] < 0) {\n            indexOfNeg1 = j;\n            tuple[j] = point;\n          } else {\n            tuple[j] = verts[nv[j]];\n          }\n        }\n\n        var o = this.orient(); //Test if neighbor cell is also a peak\n\n        if (o > 0) {\n          nv[indexOfNeg1] = n;\n          neighbor.boundary = false;\n          interior.push(neighbor);\n          tovisit.push(neighbor);\n          neighbor.lastVisited = n;\n          continue;\n        } else {\n          neighbor.lastVisited = -n;\n        }\n      }\n\n      var na = neighbor.adjacent; //Otherwise, replace neighbor with new face\n\n      var vverts = cellVerts.slice();\n      var vadj = cellAdj.slice();\n      var ncell = new Simplex(vverts, vadj, true);\n      simplices.push(ncell); //Connect to neighbor\n\n      var opposite = na.indexOf(cell);\n\n      if (opposite < 0) {\n        continue;\n      }\n\n      na[opposite] = ncell;\n      vadj[indexOfN] = neighbor; //Connect to cell\n\n      vverts[i] = -1;\n      vadj[i] = cell;\n      cellAdj[i] = ncell; //Flip facet\n\n      ncell.flip(); //Add to glue list\n\n      for (var j = 0; j <= d; ++j) {\n        var uu = vverts[j];\n\n        if (uu < 0 || uu === n) {\n          continue;\n        }\n\n        var nface = new Array(d - 1);\n        var nptr = 0;\n\n        for (var k = 0; k <= d; ++k) {\n          var vv = vverts[k];\n\n          if (vv < 0 || k === j) {\n            continue;\n          }\n\n          nface[nptr++] = vv;\n        }\n\n        glueFacets.push(new GlueFacet(nface, ncell, j));\n      }\n    }\n  } //Glue boundary facets together\n\n\n  glueFacets.sort(compareGlue);\n\n  for (var i = 0; i + 1 < glueFacets.length; i += 2) {\n    var a = glueFacets[i];\n    var b = glueFacets[i + 1];\n    var ai = a.index;\n    var bi = b.index;\n\n    if (ai < 0 || bi < 0) {\n      continue;\n    }\n\n    a.cell.adjacent[a.index] = b.cell;\n    b.cell.adjacent[b.index] = a.cell;\n  }\n};\n\nproto.insert = function (point, random) {\n  //Add point\n  var verts = this.vertices;\n  verts.push(point);\n  var cell = this.walk(point, random);\n\n  if (!cell) {\n    return;\n  } //Alias local properties\n\n\n  var d = this.dimension;\n  var tuple = this.tuple; //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\n\n  for (var i = 0; i <= d; ++i) {\n    var vv = cell.vertices[i];\n\n    if (vv < 0) {\n      tuple[i] = point;\n    } else {\n      tuple[i] = verts[vv];\n    }\n  }\n\n  var o = this.orient(tuple);\n\n  if (o < 0) {\n    return;\n  } else if (o === 0) {\n    cell = this.handleBoundaryDegeneracy(cell, point);\n\n    if (!cell) {\n      return;\n    }\n  } //Add peaks\n\n\n  this.addPeaks(point, cell);\n}; //Extract all boundary cells\n\n\nproto.boundary = function () {\n  var d = this.dimension;\n  var boundary = [];\n  var cells = this.simplices;\n  var nc = cells.length;\n\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n\n    if (c.boundary) {\n      var bcell = new Array(d);\n      var cv = c.vertices;\n      var ptr = 0;\n      var parity = 0;\n\n      for (var j = 0; j <= d; ++j) {\n        if (cv[j] >= 0) {\n          bcell[ptr++] = cv[j];\n        } else {\n          parity = j & 1;\n        }\n      }\n\n      if (parity === (d & 1)) {\n        var t = bcell[0];\n        bcell[0] = bcell[1];\n        bcell[1] = t;\n      }\n\n      boundary.push(bcell);\n    }\n  }\n\n  return boundary;\n};\n\nfunction incrementalConvexHull(points, randomSearch) {\n  var n = points.length;\n\n  if (n === 0) {\n    throw new Error(\"Must have at least d+1 points\");\n  }\n\n  var d = points[0].length;\n\n  if (n <= d) {\n    throw new Error(\"Must input at least d+1 points\");\n  } //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\n\n\n  var initialSimplex = points.slice(0, d + 1); //Make sure initial simplex is positively oriented\n\n  var o = orient.apply(void 0, initialSimplex);\n\n  if (o === 0) {\n    throw new Error(\"Input not in general position\");\n  }\n\n  var initialCoords = new Array(d + 1);\n\n  for (var i = 0; i <= d; ++i) {\n    initialCoords[i] = i;\n  }\n\n  if (o < 0) {\n    initialCoords[0] = 1;\n    initialCoords[1] = 0;\n  } //Create initial topological index, glue pointers together (kind of messy)\n\n\n  var initialCell = new Simplex(initialCoords, new Array(d + 1), false);\n  var boundary = initialCell.adjacent;\n  var list = new Array(d + 2);\n\n  for (var i = 0; i <= d; ++i) {\n    var verts = initialCoords.slice();\n\n    for (var j = 0; j <= d; ++j) {\n      if (j === i) {\n        verts[j] = -1;\n      }\n    }\n\n    var t = verts[0];\n    verts[0] = verts[1];\n    verts[1] = t;\n    var cell = new Simplex(verts, new Array(d + 1), true);\n    boundary[i] = cell;\n    list[i] = cell;\n  }\n\n  list[d + 1] = initialCell;\n\n  for (var i = 0; i <= d; ++i) {\n    var verts = boundary[i].vertices;\n    var adj = boundary[i].adjacent;\n\n    for (var j = 0; j <= d; ++j) {\n      var v = verts[j];\n\n      if (v < 0) {\n        adj[j] = initialCell;\n        continue;\n      }\n\n      for (var k = 0; k <= d; ++k) {\n        if (boundary[k].vertices.indexOf(v) < 0) {\n          adj[j] = boundary[k];\n        }\n      }\n    }\n  } //Initialize triangles\n\n\n  var triangles = new Triangulation(d, initialSimplex, list); //Insert remaining points\n\n  var useRandom = !!randomSearch;\n\n  for (var i = d + 1; i < n; ++i) {\n    triangles.insert(points[i], useRandom);\n  } //Extract boundary cells\n\n\n  return triangles.boundary();\n}","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/incremental-convex-hull/ich.js"],"names":["module","exports","incrementalConvexHull","orient","require","compareCell","compareCells","compareInt","a","b","Simplex","vertices","adjacent","boundary","lastVisited","prototype","flip","t","u","GlueFacet","cell","index","compareGlue","bakeOrient","d","code","i","push","proc","Function","join","test","BAKED","Triangulation","dimension","simplices","interior","filter","c","tuple","Array","o","proto","handleBoundaryDegeneracy","point","n","length","verts","toVisit","pop","cellVerts","cellAdj","neighbor","nv","j","vv","walk","random","initIndex","Math","outerLoop","prev","addPeaks","tovisit","indexOf","glueFacets","indexOfN","indexOfNeg1","na","vverts","slice","vadj","ncell","opposite","uu","nface","nptr","k","sort","ai","bi","insert","cells","nc","bcell","cv","ptr","parity","points","randomSearch","Error","initialSimplex","apply","initialCoords","initialCell","list","adj","v","triangles","useRandom"],"mappings":"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","sourcesContent":["\"use strict\"\n\n//High level idea:\n// 1. Use Clarkson's incremental construction to find convex hull\n// 2. Point location in triangulation by jump and walk\n\nmodule.exports = incrementalConvexHull\n\nvar orient = require(\"robust-orientation\")\nvar compareCell = require(\"simplicial-complex\").compareCells\n\nfunction compareInt(a, b) {\n  return a - b\n}\n\nfunction Simplex(vertices, adjacent, boundary) {\n  this.vertices = vertices\n  this.adjacent = adjacent\n  this.boundary = boundary\n  this.lastVisited = -1\n}\n\nSimplex.prototype.flip = function() {\n  var t = this.vertices[0]\n  this.vertices[0] = this.vertices[1]\n  this.vertices[1] = t\n  var u = this.adjacent[0]\n  this.adjacent[0] = this.adjacent[1]\n  this.adjacent[1] = u\n}\n\nfunction GlueFacet(vertices, cell, index) {\n  this.vertices = vertices\n  this.cell = cell\n  this.index = index\n}\n\nfunction compareGlue(a, b) {\n  return compareCell(a.vertices, b.vertices)\n}\n\nfunction bakeOrient(d) {\n  var code = [\"function orient(){var tuple=this.tuple;return test(\"]\n  for(var i=0; i<=d; ++i) {\n    if(i > 0) {\n      code.push(\",\")\n    }\n    code.push(\"tuple[\", i, \"]\")\n  }\n  code.push(\")}return orient\")\n  var proc = new Function(\"test\", code.join(\"\"))\n  var test = orient[d+1]\n  if(!test) {\n    test = orient\n  }\n  return proc(test)\n}\n\nvar BAKED = []\n\nfunction Triangulation(dimension, vertices, simplices) {\n  this.dimension = dimension\n  this.vertices = vertices\n  this.simplices = simplices\n  this.interior = simplices.filter(function(c) {\n    return !c.boundary\n  })\n\n  this.tuple = new Array(dimension+1)\n  for(var i=0; i<=dimension; ++i) {\n    this.tuple[i] = this.vertices[i]\n  }\n\n  var o = BAKED[dimension]\n  if(!o) {\n    o = BAKED[dimension] = bakeOrient(dimension)\n  }\n  this.orient = o\n}\n\nvar proto = Triangulation.prototype\n\n//Degenerate situation where we are on boundary, but coplanar to face\nproto.handleBoundaryDegeneracy = function(cell, point) {\n  var d = this.dimension\n  var n = this.vertices.length - 1\n  var tuple = this.tuple\n  var verts = this.vertices\n\n  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\n  var toVisit = [ cell ]\n  cell.lastVisited = -n\n  while(toVisit.length > 0) {\n    cell = toVisit.pop()\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n    for(var i=0; i<=d; ++i) {\n      var neighbor = cellAdj[i]\n      if(!neighbor.boundary || neighbor.lastVisited <= -n) {\n        continue\n      }\n      var nv = neighbor.vertices\n      for(var j=0; j<=d; ++j) {\n        var vv = nv[j]\n        if(vv < 0) {\n          tuple[j] = point\n        } else {\n          tuple[j] = verts[vv]\n        }\n      }\n      var o = this.orient()\n      if(o > 0) {\n        return neighbor\n      }\n      neighbor.lastVisited = -n\n      if(o === 0) {\n        toVisit.push(neighbor)\n      }\n    }\n  }\n  return null\n}\n\nproto.walk = function(point, random) {\n  //Alias local properties\n  var n = this.vertices.length - 1\n  var d = this.dimension\n  var verts = this.vertices\n  var tuple = this.tuple\n\n  //Compute initial jump cell\n  var initIndex = random ? (this.interior.length * Math.random())|0 : (this.interior.length-1)\n  var cell = this.interior[ initIndex ]\n\n  //Start walking\nouterLoop:\n  while(!cell.boundary) {\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n\n    for(var i=0; i<=d; ++i) {\n      tuple[i] = verts[cellVerts[i]]\n    }\n    cell.lastVisited = n\n\n    //Find farthest adjacent cell\n    for(var i=0; i<=d; ++i) {\n      var neighbor = cellAdj[i]\n      if(neighbor.lastVisited >= n) {\n        continue\n      }\n      var prev = tuple[i]\n      tuple[i] = point\n      var o = this.orient()\n      tuple[i] = prev\n      if(o < 0) {\n        cell = neighbor\n        continue outerLoop\n      } else {\n        if(!neighbor.boundary) {\n          neighbor.lastVisited = n\n        } else {\n          neighbor.lastVisited = -n\n        }\n      }\n    }\n    return\n  }\n\n  return cell\n}\n\nproto.addPeaks = function(point, cell) {\n  var n = this.vertices.length - 1\n  var d = this.dimension\n  var verts = this.vertices\n  var tuple = this.tuple\n  var interior = this.interior\n  var simplices = this.simplices\n\n  //Walking finished at boundary, time to add peaks\n  var tovisit = [ cell ]\n\n  //Stretch initial boundary cell into a peak\n  cell.lastVisited = n\n  cell.vertices[cell.vertices.indexOf(-1)] = n\n  cell.boundary = false\n  interior.push(cell)\n\n  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\n  var glueFacets = []\n\n  //Do a traversal of the boundary walking outward from starting peak\n  while(tovisit.length > 0) {\n    //Pop off peak and walk over adjacent cells\n    var cell = tovisit.pop()\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n    var indexOfN = cellVerts.indexOf(n)\n    if(indexOfN < 0) {\n      continue\n    }\n\n    for(var i=0; i<=d; ++i) {\n      if(i === indexOfN) {\n        continue\n      }\n\n      //For each boundary neighbor of the cell\n      var neighbor = cellAdj[i]\n      if(!neighbor.boundary || neighbor.lastVisited >= n) {\n        continue\n      }\n\n      var nv = neighbor.vertices\n\n      //Test if neighbor is a peak\n      if(neighbor.lastVisited !== -n) {      \n        //Compute orientation of p relative to each boundary peak\n        var indexOfNeg1 = 0\n        for(var j=0; j<=d; ++j) {\n          if(nv[j] < 0) {\n            indexOfNeg1 = j\n            tuple[j] = point\n          } else {\n            tuple[j] = verts[nv[j]]\n          }\n        }\n        var o = this.orient()\n\n        //Test if neighbor cell is also a peak\n        if(o > 0) {\n          nv[indexOfNeg1] = n\n          neighbor.boundary = false\n          interior.push(neighbor)\n          tovisit.push(neighbor)\n          neighbor.lastVisited = n\n          continue\n        } else {\n          neighbor.lastVisited = -n\n        }\n      }\n\n      var na = neighbor.adjacent\n\n      //Otherwise, replace neighbor with new face\n      var vverts = cellVerts.slice()\n      var vadj = cellAdj.slice()\n      var ncell = new Simplex(vverts, vadj, true)\n      simplices.push(ncell)\n\n      //Connect to neighbor\n      var opposite = na.indexOf(cell)\n      if(opposite < 0) {\n        continue\n      }\n      na[opposite] = ncell\n      vadj[indexOfN] = neighbor\n\n      //Connect to cell\n      vverts[i] = -1\n      vadj[i] = cell\n      cellAdj[i] = ncell\n\n      //Flip facet\n      ncell.flip()\n\n      //Add to glue list\n      for(var j=0; j<=d; ++j) {\n        var uu = vverts[j]\n        if(uu < 0 || uu === n) {\n          continue\n        }\n        var nface = new Array(d-1)\n        var nptr = 0\n        for(var k=0; k<=d; ++k) {\n          var vv = vverts[k]\n          if(vv < 0 || k === j) {\n            continue\n          }\n          nface[nptr++] = vv\n        }\n        glueFacets.push(new GlueFacet(nface, ncell, j))\n      }\n    }\n  }\n\n  //Glue boundary facets together\n  glueFacets.sort(compareGlue)\n\n  for(var i=0; i+1<glueFacets.length; i+=2) {\n    var a = glueFacets[i]\n    var b = glueFacets[i+1]\n    var ai = a.index\n    var bi = b.index\n    if(ai < 0 || bi < 0) {\n      continue\n    }\n    a.cell.adjacent[a.index] = b.cell\n    b.cell.adjacent[b.index] = a.cell\n  }\n}\n\nproto.insert = function(point, random) {\n  //Add point\n  var verts = this.vertices\n  verts.push(point)\n\n  var cell = this.walk(point, random)\n  if(!cell) {\n    return\n  }\n\n  //Alias local properties\n  var d = this.dimension\n  var tuple = this.tuple\n\n  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\n  for(var i=0; i<=d; ++i) {\n    var vv = cell.vertices[i]\n    if(vv < 0) {\n      tuple[i] = point\n    } else {\n      tuple[i] = verts[vv]\n    }\n  }\n  var o = this.orient(tuple)\n  if(o < 0) {\n    return\n  } else if(o === 0) {\n    cell = this.handleBoundaryDegeneracy(cell, point)\n    if(!cell) {\n      return\n    }\n  }\n\n  //Add peaks\n  this.addPeaks(point, cell)\n}\n\n//Extract all boundary cells\nproto.boundary = function() {\n  var d = this.dimension\n  var boundary = []\n  var cells = this.simplices\n  var nc = cells.length\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    if(c.boundary) {\n      var bcell = new Array(d)\n      var cv = c.vertices\n      var ptr = 0\n      var parity = 0\n      for(var j=0; j<=d; ++j) {\n        if(cv[j] >= 0) {\n          bcell[ptr++] = cv[j]\n        } else {\n          parity = j&1\n        }\n      }\n      if(parity === (d&1)) {\n        var t = bcell[0]\n        bcell[0] = bcell[1]\n        bcell[1] = t\n      }\n      boundary.push(bcell)\n    }\n  }\n  return boundary\n}\n\nfunction incrementalConvexHull(points, randomSearch) {\n  var n = points.length\n  if(n === 0) {\n    throw new Error(\"Must have at least d+1 points\")\n  }\n  var d = points[0].length\n  if(n <= d) {\n    throw new Error(\"Must input at least d+1 points\")\n  }\n\n  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\n  var initialSimplex = points.slice(0, d+1)\n\n  //Make sure initial simplex is positively oriented\n  var o = orient.apply(void 0, initialSimplex)\n  if(o === 0) {\n    throw new Error(\"Input not in general position\")\n  }\n  var initialCoords = new Array(d+1)\n  for(var i=0; i<=d; ++i) {\n    initialCoords[i] = i\n  }\n  if(o < 0) {\n    initialCoords[0] = 1\n    initialCoords[1] = 0\n  }\n\n  //Create initial topological index, glue pointers together (kind of messy)\n  var initialCell = new Simplex(initialCoords, new Array(d+1), false)\n  var boundary = initialCell.adjacent\n  var list = new Array(d+2)\n  for(var i=0; i<=d; ++i) {\n    var verts = initialCoords.slice()\n    for(var j=0; j<=d; ++j) {\n      if(j === i) {\n        verts[j] = -1\n      }\n    }\n    var t = verts[0]\n    verts[0] = verts[1]\n    verts[1] = t\n    var cell = new Simplex(verts, new Array(d+1), true)\n    boundary[i] = cell\n    list[i] = cell\n  }\n  list[d+1] = initialCell\n  for(var i=0; i<=d; ++i) {\n    var verts = boundary[i].vertices\n    var adj = boundary[i].adjacent\n    for(var j=0; j<=d; ++j) {\n      var v = verts[j]\n      if(v < 0) {\n        adj[j] = initialCell\n        continue\n      }\n      for(var k=0; k<=d; ++k) {\n        if(boundary[k].vertices.indexOf(v) < 0) {\n          adj[j] = boundary[k]\n        }\n      }\n    }\n  }\n\n  //Initialize triangles\n  var triangles = new Triangulation(d, initialSimplex, list)\n\n  //Insert remaining points\n  var useRandom = !!randomSearch\n  for(var i=d+1; i<n; ++i) {\n    triangles.insert(points[i], useRandom)\n  }\n  \n  //Extract boundary cells\n  return triangles.boundary()\n}"]},"metadata":{},"sourceType":"script"}