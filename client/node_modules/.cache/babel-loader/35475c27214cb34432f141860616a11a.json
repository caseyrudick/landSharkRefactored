{"ast":null,"code":"\"use strict\";\n\nmodule.exports = surfaceNets;\n\nvar generateContourExtractor = require(\"ndarray-extract-contour\");\n\nvar triangulateCube = require(\"triangulate-hypercube\");\n\nvar zeroCrossings = require(\"zero-crossings\");\n\nfunction buildSurfaceNets(order, dtype) {\n  var dimension = order.length;\n  var code = [\"'use strict';\"];\n  var funcName = \"surfaceNets\" + order.join(\"_\") + \"d\" + dtype; //Contour extraction function\n\n  code.push(\"var contour=genContour({\", \"order:[\", order.join(), \"],\", \"scalarArguments: 3,\", \"phase:function phaseFunc(p,a,b,c) { return (p > c)|0 },\");\n\n  if (dtype === \"generic\") {\n    code.push(\"getters:[0],\");\n  } //Generate vertex function\n\n\n  var cubeArgs = [];\n  var extraArgs = [];\n\n  for (var i = 0; i < dimension; ++i) {\n    cubeArgs.push(\"d\" + i);\n    extraArgs.push(\"d\" + i);\n  }\n\n  for (var i = 0; i < 1 << dimension; ++i) {\n    cubeArgs.push(\"v\" + i);\n    extraArgs.push(\"v\" + i);\n  }\n\n  for (var i = 0; i < 1 << dimension; ++i) {\n    cubeArgs.push(\"p\" + i);\n    extraArgs.push(\"p\" + i);\n  }\n\n  cubeArgs.push(\"a\", \"b\", \"c\");\n  extraArgs.push(\"a\", \"c\");\n  code.push(\"vertex:function vertexFunc(\", cubeArgs.join(), \"){\"); //Mask args together\n\n  var maskStr = [];\n\n  for (var i = 0; i < 1 << dimension; ++i) {\n    maskStr.push(\"(p\" + i + \"<<\" + i + \")\");\n  } //Generate variables and giganto switch statement\n\n\n  code.push(\"var m=(\", maskStr.join(\"+\"), \")|0;if(m===0||m===\", (1 << (1 << dimension)) - 1, \"){return}\");\n  var extraFuncs = [];\n  var currentFunc = [];\n\n  if (1 << (1 << dimension) <= 128) {\n    code.push(\"switch(m){\");\n    currentFunc = code;\n  } else {\n    code.push(\"switch(m>>>7){\");\n  }\n\n  for (var i = 0; i < 1 << (1 << dimension); ++i) {\n    if (1 << (1 << dimension) > 128) {\n      if (i % 128 === 0) {\n        if (extraFuncs.length > 0) {\n          currentFunc.push(\"}}\");\n        }\n\n        var efName = \"vExtra\" + extraFuncs.length;\n        code.push(\"case \", i >>> 7, \":\", efName, \"(m&0x7f,\", extraArgs.join(), \");break;\");\n        currentFunc = [\"function \", efName, \"(m,\", extraArgs.join(), \"){switch(m){\"];\n        extraFuncs.push(currentFunc);\n      }\n    }\n\n    currentFunc.push(\"case \", i & 0x7f, \":\");\n    var crossings = new Array(dimension);\n    var denoms = new Array(dimension);\n    var crossingCount = new Array(dimension);\n    var bias = new Array(dimension);\n    var totalCrossings = 0;\n\n    for (var j = 0; j < dimension; ++j) {\n      crossings[j] = [];\n      denoms[j] = [];\n      crossingCount[j] = 0;\n      bias[j] = 0;\n    }\n\n    for (var j = 0; j < 1 << dimension; ++j) {\n      for (var k = 0; k < dimension; ++k) {\n        var u = j ^ 1 << k;\n\n        if (u > j) {\n          continue;\n        }\n\n        if (!(i & 1 << u) !== !(i & 1 << j)) {\n          var sign = 1;\n\n          if (i & 1 << u) {\n            denoms[k].push(\"v\" + u + \"-v\" + j);\n          } else {\n            denoms[k].push(\"v\" + j + \"-v\" + u);\n            sign = -sign;\n          }\n\n          if (sign < 0) {\n            crossings[k].push(\"-v\" + j + \"-v\" + u);\n            crossingCount[k] += 2;\n          } else {\n            crossings[k].push(\"v\" + j + \"+v\" + u);\n            crossingCount[k] -= 2;\n          }\n\n          totalCrossings += 1;\n\n          for (var l = 0; l < dimension; ++l) {\n            if (l === k) {\n              continue;\n            }\n\n            if (u & 1 << l) {\n              bias[l] += 1;\n            } else {\n              bias[l] -= 1;\n            }\n          }\n        }\n      }\n    }\n\n    var vertexStr = [];\n\n    for (var k = 0; k < dimension; ++k) {\n      if (crossings[k].length === 0) {\n        vertexStr.push(\"d\" + k + \"-0.5\");\n      } else {\n        var cStr = \"\";\n\n        if (crossingCount[k] < 0) {\n          cStr = crossingCount[k] + \"*c\";\n        } else if (crossingCount[k] > 0) {\n          cStr = \"+\" + crossingCount[k] + \"*c\";\n        }\n\n        var weight = 0.5 * (crossings[k].length / totalCrossings);\n        var shift = 0.5 + 0.5 * (bias[k] / totalCrossings);\n        vertexStr.push(\"d\" + k + \"-\" + shift + \"-\" + weight + \"*(\" + crossings[k].join(\"+\") + cStr + \")/(\" + denoms[k].join(\"+\") + \")\");\n      }\n    }\n\n    currentFunc.push(\"a.push([\", vertexStr.join(), \"]);\", \"break;\");\n  }\n\n  code.push(\"}},\");\n\n  if (extraFuncs.length > 0) {\n    currentFunc.push(\"}}\");\n  } //Create face function\n\n\n  var faceArgs = [];\n\n  for (var i = 0; i < 1 << dimension - 1; ++i) {\n    faceArgs.push(\"v\" + i);\n  }\n\n  faceArgs.push(\"c0\", \"c1\", \"p0\", \"p1\", \"a\", \"b\", \"c\");\n  code.push(\"cell:function cellFunc(\", faceArgs.join(), \"){\");\n  var facets = triangulateCube(dimension - 1);\n  code.push(\"if(p0){b.push(\", facets.map(function (f) {\n    return \"[\" + f.map(function (v) {\n      return \"v\" + v;\n    }) + \"]\";\n  }).join(), \")}else{b.push(\", facets.map(function (f) {\n    var e = f.slice();\n    e.reverse();\n    return \"[\" + e.map(function (v) {\n      return \"v\" + v;\n    }) + \"]\";\n  }).join(), \")}}});function \", funcName, \"(array,level){var verts=[],cells=[];contour(array,verts,cells,level);return {positions:verts,cells:cells};} return \", funcName, \";\");\n\n  for (var i = 0; i < extraFuncs.length; ++i) {\n    code.push(extraFuncs[i].join(\"\"));\n  } //Compile and link\n\n\n  var proc = new Function(\"genContour\", code.join(\"\"));\n  return proc(generateContourExtractor);\n} //1D case: Need to handle specially\n\n\nfunction mesh1D(array, level) {\n  var zc = zeroCrossings(array, level);\n  var n = zc.length;\n  var npos = new Array(n);\n  var ncel = new Array(n);\n\n  for (var i = 0; i < n; ++i) {\n    npos[i] = [zc[i]];\n    ncel[i] = [i];\n  }\n\n  return {\n    positions: npos,\n    cells: ncel\n  };\n}\n\nvar CACHE = {};\n\nfunction surfaceNets(array, level) {\n  if (array.dimension <= 0) {\n    return {\n      positions: [],\n      cells: []\n    };\n  } else if (array.dimension === 1) {\n    return mesh1D(array, level);\n  }\n\n  var typesig = array.order.join() + \"-\" + array.dtype;\n  var proc = CACHE[typesig];\n  var level = +level || 0.0;\n\n  if (!proc) {\n    proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype);\n  }\n\n  return proc(array, level);\n}","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/surface-nets/surfacenets.js"],"names":["module","exports","surfaceNets","generateContourExtractor","require","triangulateCube","zeroCrossings","buildSurfaceNets","order","dtype","dimension","length","code","funcName","join","push","cubeArgs","extraArgs","i","maskStr","extraFuncs","currentFunc","efName","crossings","Array","denoms","crossingCount","bias","totalCrossings","j","k","u","sign","l","vertexStr","cStr","weight","shift","faceArgs","facets","map","f","v","e","slice","reverse","proc","Function","mesh1D","array","level","zc","n","npos","ncel","positions","cells","CACHE","typesig"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,WAAjB;;AAEA,IAAIC,wBAAwB,GAAGC,OAAO,CAAC,yBAAD,CAAtC;;AACA,IAAIC,eAAe,GAAGD,OAAO,CAAC,uBAAD,CAA7B;;AACA,IAAIE,aAAa,GAAGF,OAAO,CAAC,gBAAD,CAA3B;;AAEA,SAASG,gBAAT,CAA0BC,KAA1B,EAAiCC,KAAjC,EAAwC;AACtC,MAAIC,SAAS,GAAGF,KAAK,CAACG,MAAtB;AACA,MAAIC,IAAI,GAAG,CAAC,eAAD,CAAX;AACA,MAAIC,QAAQ,GAAG,gBAAgBL,KAAK,CAACM,IAAN,CAAW,GAAX,CAAhB,GAAkC,GAAlC,GAAwCL,KAAvD,CAHsC,CAKtC;;AACAG,EAAAA,IAAI,CAACG,IAAL,CACE,0BADF,EAEI,SAFJ,EAEeP,KAAK,CAACM,IAAN,EAFf,EAE6B,IAF7B,EAGI,qBAHJ,EAII,yDAJJ;;AAKA,MAAGL,KAAK,KAAK,SAAb,EAAwB;AACtBG,IAAAA,IAAI,CAACG,IAAL,CAAU,cAAV;AACD,GAbqC,CAetC;;;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,SAAS,GAAG,EAAhB;;AACA,OAAI,IAAIC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACR,SAAf,EAA0B,EAAEQ,CAA5B,EAA+B;AAC7BF,IAAAA,QAAQ,CAACD,IAAT,CAAc,MAAMG,CAApB;AACAD,IAAAA,SAAS,CAACF,IAAV,CAAe,MAAMG,CAArB;AACD;;AACD,OAAI,IAAIA,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAE,KAAGR,SAAnB,EAA+B,EAAEQ,CAAjC,EAAoC;AAClCF,IAAAA,QAAQ,CAACD,IAAT,CAAc,MAAMG,CAApB;AACAD,IAAAA,SAAS,CAACF,IAAV,CAAe,MAAMG,CAArB;AACD;;AACD,OAAI,IAAIA,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAE,KAAGR,SAAnB,EAA+B,EAAEQ,CAAjC,EAAoC;AAClCF,IAAAA,QAAQ,CAACD,IAAT,CAAc,MAAMG,CAApB;AACAD,IAAAA,SAAS,CAACF,IAAV,CAAe,MAAMG,CAArB;AACD;;AACDF,EAAAA,QAAQ,CAACD,IAAT,CAAc,GAAd,EAAmB,GAAnB,EAAwB,GAAxB;AACAE,EAAAA,SAAS,CAACF,IAAV,CAAe,GAAf,EAAoB,GAApB;AACAH,EAAAA,IAAI,CAACG,IAAL,CAAU,6BAAV,EAAyCC,QAAQ,CAACF,IAAT,EAAzC,EAA0D,IAA1D,EAhCsC,CAiCtC;;AACA,MAAIK,OAAO,GAAG,EAAd;;AACA,OAAI,IAAID,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAE,KAAGR,SAAnB,EAA+B,EAAEQ,CAAjC,EAAoC;AAClCC,IAAAA,OAAO,CAACJ,IAAR,CAAa,OAAOG,CAAP,GAAW,IAAX,GAAkBA,CAAlB,GAAsB,GAAnC;AACD,GArCqC,CAsCtC;;;AACAN,EAAAA,IAAI,CAACG,IAAL,CAAU,SAAV,EAAqBI,OAAO,CAACL,IAAR,CAAa,GAAb,CAArB,EAAwC,oBAAxC,EAA8D,CAAC,MAAI,KAAGJ,SAAP,CAAD,IAAoB,CAAlF,EAAqF,WAArF;AACA,MAAIU,UAAU,GAAG,EAAjB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AACA,MAAG,MAAI,KAAGX,SAAP,KAAqB,GAAxB,EAA6B;AAC3BE,IAAAA,IAAI,CAACG,IAAL,CAAU,YAAV;AACAM,IAAAA,WAAW,GAAGT,IAAd;AACD,GAHD,MAGO;AACLA,IAAAA,IAAI,CAACG,IAAL,CAAU,gBAAV;AACD;;AACD,OAAI,IAAIG,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,MAAI,KAAGR,SAAP,CAAf,EAAkC,EAAEQ,CAApC,EAAuC;AACrC,QAAG,MAAI,KAAGR,SAAP,IAAoB,GAAvB,EAA4B;AAC1B,UAAIQ,CAAC,GAAC,GAAH,KAAU,CAAb,EAAgB;AACd,YAAGE,UAAU,CAACT,MAAX,GAAoB,CAAvB,EAA0B;AACxBU,UAAAA,WAAW,CAACN,IAAZ,CAAiB,IAAjB;AACD;;AACD,YAAIO,MAAM,GAAG,WAAWF,UAAU,CAACT,MAAnC;AACAC,QAAAA,IAAI,CAACG,IAAL,CAAU,OAAV,EAAoBG,CAAC,KAAG,CAAxB,EAA4B,GAA5B,EAAiCI,MAAjC,EAAyC,UAAzC,EAAqDL,SAAS,CAACH,IAAV,EAArD,EAAuE,UAAvE;AACAO,QAAAA,WAAW,GAAG,CACZ,WADY,EACCC,MADD,EACS,KADT,EACgBL,SAAS,CAACH,IAAV,EADhB,EACkC,cADlC,CAAd;AAGAM,QAAAA,UAAU,CAACL,IAAX,CAAgBM,WAAhB;AACD;AACF;;AACDA,IAAAA,WAAW,CAACN,IAAZ,CAAiB,OAAjB,EAA2BG,CAAC,GAAC,IAA7B,EAAoC,GAApC;AACA,QAAIK,SAAS,GAAG,IAAIC,KAAJ,CAAUd,SAAV,CAAhB;AACA,QAAIe,MAAM,GAAG,IAAID,KAAJ,CAAUd,SAAV,CAAb;AACA,QAAIgB,aAAa,GAAG,IAAIF,KAAJ,CAAUd,SAAV,CAApB;AACA,QAAIiB,IAAI,GAAG,IAAIH,KAAJ,CAAUd,SAAV,CAAX;AACA,QAAIkB,cAAc,GAAG,CAArB;;AACA,SAAI,IAAIC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACnB,SAAf,EAA0B,EAAEmB,CAA5B,EAA+B;AAC7BN,MAAAA,SAAS,CAACM,CAAD,CAAT,GAAe,EAAf;AACAJ,MAAAA,MAAM,CAACI,CAAD,CAAN,GAAY,EAAZ;AACAH,MAAAA,aAAa,CAACG,CAAD,CAAb,GAAmB,CAAnB;AACAF,MAAAA,IAAI,CAACE,CAAD,CAAJ,GAAU,CAAV;AACD;;AACD,SAAI,IAAIA,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAE,KAAGnB,SAAnB,EAA+B,EAAEmB,CAAjC,EAAoC;AAClC,WAAI,IAAIC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACpB,SAAf,EAA0B,EAAEoB,CAA5B,EAA+B;AAC7B,YAAIC,CAAC,GAAGF,CAAC,GAAI,KAAGC,CAAhB;;AACA,YAAGC,CAAC,GAAGF,CAAP,EAAU;AACR;AACD;;AACD,YAAG,EAAEX,CAAC,GAAE,KAAGa,CAAR,MAAgB,EAAEb,CAAC,GAAE,KAAGW,CAAR,CAAnB,EAAgC;AAC9B,cAAIG,IAAI,GAAG,CAAX;;AACA,cAAGd,CAAC,GAAE,KAAGa,CAAT,EAAa;AACXN,YAAAA,MAAM,CAACK,CAAD,CAAN,CAAUf,IAAV,CAAe,MAAMgB,CAAN,GAAU,IAAV,GAAiBF,CAAhC;AACD,WAFD,MAEO;AACLJ,YAAAA,MAAM,CAACK,CAAD,CAAN,CAAUf,IAAV,CAAe,MAAMc,CAAN,GAAU,IAAV,GAAiBE,CAAhC;AACAC,YAAAA,IAAI,GAAG,CAACA,IAAR;AACD;;AACD,cAAGA,IAAI,GAAG,CAAV,EAAa;AACXT,YAAAA,SAAS,CAACO,CAAD,CAAT,CAAaf,IAAb,CAAkB,OAAOc,CAAP,GAAW,IAAX,GAAkBE,CAApC;AACAL,YAAAA,aAAa,CAACI,CAAD,CAAb,IAAoB,CAApB;AACD,WAHD,MAGO;AACLP,YAAAA,SAAS,CAACO,CAAD,CAAT,CAAaf,IAAb,CAAkB,MAAMc,CAAN,GAAU,IAAV,GAAiBE,CAAnC;AACAL,YAAAA,aAAa,CAACI,CAAD,CAAb,IAAoB,CAApB;AACD;;AACDF,UAAAA,cAAc,IAAI,CAAlB;;AACA,eAAI,IAAIK,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACvB,SAAf,EAA0B,EAAEuB,CAA5B,EAA+B;AAC7B,gBAAGA,CAAC,KAAKH,CAAT,EAAY;AACV;AACD;;AACD,gBAAGC,CAAC,GAAE,KAAGE,CAAT,EAAa;AACXN,cAAAA,IAAI,CAACM,CAAD,CAAJ,IAAW,CAAX;AACD,aAFD,MAEO;AACLN,cAAAA,IAAI,CAACM,CAAD,CAAJ,IAAW,CAAX;AACD;AACF;AACF;AACF;AACF;;AACD,QAAIC,SAAS,GAAG,EAAhB;;AACA,SAAI,IAAIJ,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACpB,SAAf,EAA0B,EAAEoB,CAA5B,EAA+B;AAC7B,UAAGP,SAAS,CAACO,CAAD,CAAT,CAAanB,MAAb,KAAwB,CAA3B,EAA8B;AAC5BuB,QAAAA,SAAS,CAACnB,IAAV,CAAe,MAAMe,CAAN,GAAU,MAAzB;AACD,OAFD,MAEO;AACL,YAAIK,IAAI,GAAG,EAAX;;AACA,YAAGT,aAAa,CAACI,CAAD,CAAb,GAAmB,CAAtB,EAAyB;AACvBK,UAAAA,IAAI,GAAGT,aAAa,CAACI,CAAD,CAAb,GAAmB,IAA1B;AACD,SAFD,MAEO,IAAGJ,aAAa,CAACI,CAAD,CAAb,GAAmB,CAAtB,EAAyB;AAC9BK,UAAAA,IAAI,GAAG,MAAMT,aAAa,CAACI,CAAD,CAAnB,GAAyB,IAAhC;AACD;;AACD,YAAIM,MAAM,GAAG,OAAOb,SAAS,CAACO,CAAD,CAAT,CAAanB,MAAb,GAAsBiB,cAA7B,CAAb;AACA,YAAIS,KAAK,GAAG,MAAM,OAAOV,IAAI,CAACG,CAAD,CAAJ,GAAUF,cAAjB,CAAlB;AACAM,QAAAA,SAAS,CAACnB,IAAV,CAAe,MAAMe,CAAN,GAAU,GAAV,GAAgBO,KAAhB,GAAwB,GAAxB,GAA8BD,MAA9B,GAAuC,IAAvC,GAA8Cb,SAAS,CAACO,CAAD,CAAT,CAAahB,IAAb,CAAkB,GAAlB,CAA9C,GAAuEqB,IAAvE,GAA8E,KAA9E,GAAsFV,MAAM,CAACK,CAAD,CAAN,CAAUhB,IAAV,CAAe,GAAf,CAAtF,GAA4G,GAA3H;AAED;AACF;;AACDO,IAAAA,WAAW,CAACN,IAAZ,CAAiB,UAAjB,EAA6BmB,SAAS,CAACpB,IAAV,EAA7B,EAA+C,KAA/C,EACE,QADF;AAED;;AACDF,EAAAA,IAAI,CAACG,IAAL,CAAU,KAAV;;AACA,MAAGK,UAAU,CAACT,MAAX,GAAoB,CAAvB,EAA0B;AACxBU,IAAAA,WAAW,CAACN,IAAZ,CAAiB,IAAjB;AACD,GApIqC,CAsItC;;;AACA,MAAIuB,QAAQ,GAAG,EAAf;;AACA,OAAI,IAAIpB,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAE,KAAIR,SAAS,GAAC,CAA9B,EAAmC,EAAEQ,CAArC,EAAwC;AACtCoB,IAAAA,QAAQ,CAACvB,IAAT,CAAc,MAAMG,CAApB;AACD;;AACDoB,EAAAA,QAAQ,CAACvB,IAAT,CAAc,IAAd,EAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,GAAtC,EAA2C,GAA3C,EAAgD,GAAhD;AACAH,EAAAA,IAAI,CAACG,IAAL,CAAU,yBAAV,EAAqCuB,QAAQ,CAACxB,IAAT,EAArC,EAAsD,IAAtD;AAEA,MAAIyB,MAAM,GAAGlC,eAAe,CAACK,SAAS,GAAC,CAAX,CAA5B;AACAE,EAAAA,IAAI,CAACG,IAAL,CAAU,gBAAV,EACEwB,MAAM,CAACC,GAAP,CAAW,UAASC,CAAT,EAAY;AACrB,WAAO,MAAMA,CAAC,CAACD,GAAF,CAAM,UAASE,CAAT,EAAY;AAC7B,aAAO,MAAMA,CAAb;AACD,KAFY,CAAN,GAEF,GAFL;AAGD,GAJD,EAIG5B,IAJH,EADF,EAKa,gBALb,EAMEyB,MAAM,CAACC,GAAP,CAAW,UAASC,CAAT,EAAY;AACrB,QAAIE,CAAC,GAAGF,CAAC,CAACG,KAAF,EAAR;AACAD,IAAAA,CAAC,CAACE,OAAF;AACA,WAAO,MAAMF,CAAC,CAACH,GAAF,CAAM,UAASE,CAAT,EAAY;AAC7B,aAAO,MAAMA,CAAb;AACD,KAFY,CAAN,GAEF,GAFL;AAGD,GAND,EAMG5B,IANH,EANF,EAaE,iBAbF,EAaqBD,QAbrB,EAa+B,qHAb/B,EAasJA,QAbtJ,EAagK,GAbhK;;AAeA,OAAI,IAAIK,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACE,UAAU,CAACT,MAA1B,EAAkC,EAAEO,CAApC,EAAuC;AACrCN,IAAAA,IAAI,CAACG,IAAL,CAAUK,UAAU,CAACF,CAAD,CAAV,CAAcJ,IAAd,CAAmB,EAAnB,CAAV;AACD,GAhKqC,CAkKtC;;;AACA,MAAIgC,IAAI,GAAG,IAAIC,QAAJ,CAAa,YAAb,EAA2BnC,IAAI,CAACE,IAAL,CAAU,EAAV,CAA3B,CAAX;AACA,SAAOgC,IAAI,CAAC3C,wBAAD,CAAX;AACD,C,CAED;;;AACA,SAAS6C,MAAT,CAAgBC,KAAhB,EAAuBC,KAAvB,EAA8B;AAC5B,MAAIC,EAAE,GAAG7C,aAAa,CAAC2C,KAAD,EAAQC,KAAR,CAAtB;AACA,MAAIE,CAAC,GAAGD,EAAE,CAACxC,MAAX;AACA,MAAI0C,IAAI,GAAG,IAAI7B,KAAJ,CAAU4B,CAAV,CAAX;AACA,MAAIE,IAAI,GAAG,IAAI9B,KAAJ,CAAU4B,CAAV,CAAX;;AACA,OAAI,IAAIlC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACkC,CAAf,EAAkB,EAAElC,CAApB,EAAuB;AACrBmC,IAAAA,IAAI,CAACnC,CAAD,CAAJ,GAAU,CAAEiC,EAAE,CAACjC,CAAD,CAAJ,CAAV;AACAoC,IAAAA,IAAI,CAACpC,CAAD,CAAJ,GAAU,CAAEA,CAAF,CAAV;AACD;;AACD,SAAO;AACLqC,IAAAA,SAAS,EAAEF,IADN;AAELG,IAAAA,KAAK,EAAEF;AAFF,GAAP;AAID;;AAED,IAAIG,KAAK,GAAG,EAAZ;;AAEA,SAASvD,WAAT,CAAqB+C,KAArB,EAA2BC,KAA3B,EAAkC;AAChC,MAAGD,KAAK,CAACvC,SAAN,IAAmB,CAAtB,EAAyB;AACvB,WAAO;AAAE6C,MAAAA,SAAS,EAAE,EAAb;AAAiBC,MAAAA,KAAK,EAAE;AAAxB,KAAP;AACD,GAFD,MAEO,IAAGP,KAAK,CAACvC,SAAN,KAAoB,CAAvB,EAA0B;AAC/B,WAAOsC,MAAM,CAACC,KAAD,EAAQC,KAAR,CAAb;AACD;;AACD,MAAIQ,OAAO,GAAGT,KAAK,CAACzC,KAAN,CAAYM,IAAZ,KAAqB,GAArB,GAA2BmC,KAAK,CAACxC,KAA/C;AACA,MAAIqC,IAAI,GAAGW,KAAK,CAACC,OAAD,CAAhB;AACA,MAAIR,KAAK,GAAI,CAACA,KAAF,IAAY,GAAxB;;AACA,MAAG,CAACJ,IAAJ,EAAU;AACRA,IAAAA,IAAI,GAAGW,KAAK,CAACC,OAAD,CAAL,GAAiBnD,gBAAgB,CAAC0C,KAAK,CAACzC,KAAP,EAAcyC,KAAK,CAACxC,KAApB,CAAxC;AACD;;AACD,SAAOqC,IAAI,CAACG,KAAD,EAAOC,KAAP,CAAX;AACD","sourcesContent":["\"use strict\"\n\nmodule.exports = surfaceNets\n\nvar generateContourExtractor = require(\"ndarray-extract-contour\")\nvar triangulateCube = require(\"triangulate-hypercube\")\nvar zeroCrossings = require(\"zero-crossings\")\n\nfunction buildSurfaceNets(order, dtype) {\n  var dimension = order.length\n  var code = [\"'use strict';\"]\n  var funcName = \"surfaceNets\" + order.join(\"_\") + \"d\" + dtype\n\n  //Contour extraction function\n  code.push(\n    \"var contour=genContour({\",\n      \"order:[\", order.join(), \"],\",\n      \"scalarArguments: 3,\",\n      \"phase:function phaseFunc(p,a,b,c) { return (p > c)|0 },\")\n  if(dtype === \"generic\") {\n    code.push(\"getters:[0],\")\n  }\n\n  //Generate vertex function\n  var cubeArgs = []\n  var extraArgs = []\n  for(var i=0; i<dimension; ++i) {\n    cubeArgs.push(\"d\" + i)\n    extraArgs.push(\"d\" + i)\n  }\n  for(var i=0; i<(1<<dimension); ++i) {\n    cubeArgs.push(\"v\" + i)\n    extraArgs.push(\"v\" + i)\n  }\n  for(var i=0; i<(1<<dimension); ++i) {\n    cubeArgs.push(\"p\" + i)\n    extraArgs.push(\"p\" + i)\n  }\n  cubeArgs.push(\"a\", \"b\", \"c\")\n  extraArgs.push(\"a\", \"c\")\n  code.push(\"vertex:function vertexFunc(\", cubeArgs.join(), \"){\")\n  //Mask args together\n  var maskStr = []\n  for(var i=0; i<(1<<dimension); ++i) {\n    maskStr.push(\"(p\" + i + \"<<\" + i + \")\")\n  }\n  //Generate variables and giganto switch statement\n  code.push(\"var m=(\", maskStr.join(\"+\"), \")|0;if(m===0||m===\", (1<<(1<<dimension))-1, \"){return}\")\n  var extraFuncs = []\n  var currentFunc = []\n  if(1<<(1<<dimension) <= 128) {\n    code.push(\"switch(m){\")\n    currentFunc = code\n  } else {\n    code.push(\"switch(m>>>7){\")\n  }\n  for(var i=0; i<1<<(1<<dimension); ++i) {\n    if(1<<(1<<dimension) > 128) {\n      if((i%128)===0) {\n        if(extraFuncs.length > 0) {\n          currentFunc.push(\"}}\")\n        }\n        var efName = \"vExtra\" + extraFuncs.length\n        code.push(\"case \", (i>>>7), \":\", efName, \"(m&0x7f,\", extraArgs.join(), \");break;\")\n        currentFunc = [\n          \"function \", efName, \"(m,\", extraArgs.join(), \"){switch(m){\"\n        ]\n        extraFuncs.push(currentFunc)\n      }  \n    }\n    currentFunc.push(\"case \", (i&0x7f), \":\")\n    var crossings = new Array(dimension)\n    var denoms = new Array(dimension)\n    var crossingCount = new Array(dimension)\n    var bias = new Array(dimension)\n    var totalCrossings = 0\n    for(var j=0; j<dimension; ++j) {\n      crossings[j] = []\n      denoms[j] = []\n      crossingCount[j] = 0\n      bias[j] = 0\n    }\n    for(var j=0; j<(1<<dimension); ++j) {\n      for(var k=0; k<dimension; ++k) {\n        var u = j ^ (1<<k)\n        if(u > j) {\n          continue\n        }\n        if(!(i&(1<<u)) !== !(i&(1<<j))) {\n          var sign = 1\n          if(i&(1<<u)) {\n            denoms[k].push(\"v\" + u + \"-v\" + j)\n          } else {\n            denoms[k].push(\"v\" + j + \"-v\" + u)\n            sign = -sign\n          }\n          if(sign < 0) {\n            crossings[k].push(\"-v\" + j + \"-v\" + u)\n            crossingCount[k] += 2\n          } else {\n            crossings[k].push(\"v\" + j + \"+v\" + u)\n            crossingCount[k] -= 2            \n          }\n          totalCrossings += 1\n          for(var l=0; l<dimension; ++l) {\n            if(l === k) {\n              continue\n            }\n            if(u&(1<<l)) {\n              bias[l] += 1\n            } else {\n              bias[l] -= 1\n            }\n          }\n        }\n      }\n    }\n    var vertexStr = []\n    for(var k=0; k<dimension; ++k) {\n      if(crossings[k].length === 0) {\n        vertexStr.push(\"d\" + k + \"-0.5\")\n      } else {\n        var cStr = \"\"\n        if(crossingCount[k] < 0) {\n          cStr = crossingCount[k] + \"*c\"\n        } else if(crossingCount[k] > 0) {\n          cStr = \"+\" + crossingCount[k] + \"*c\"\n        }\n        var weight = 0.5 * (crossings[k].length / totalCrossings)\n        var shift = 0.5 + 0.5 * (bias[k] / totalCrossings)\n        vertexStr.push(\"d\" + k + \"-\" + shift + \"-\" + weight + \"*(\" + crossings[k].join(\"+\") + cStr + \")/(\" + denoms[k].join(\"+\") + \")\")\n        \n      }\n    }\n    currentFunc.push(\"a.push([\", vertexStr.join(), \"]);\",\n      \"break;\")\n  }\n  code.push(\"}},\")\n  if(extraFuncs.length > 0) {\n    currentFunc.push(\"}}\")\n  }\n\n  //Create face function\n  var faceArgs = []\n  for(var i=0; i<(1<<(dimension-1)); ++i) {\n    faceArgs.push(\"v\" + i)\n  }\n  faceArgs.push(\"c0\", \"c1\", \"p0\", \"p1\", \"a\", \"b\", \"c\")\n  code.push(\"cell:function cellFunc(\", faceArgs.join(), \"){\")\n\n  var facets = triangulateCube(dimension-1)\n  code.push(\"if(p0){b.push(\",\n    facets.map(function(f) {\n      return \"[\" + f.map(function(v) {\n        return \"v\" + v\n      }) + \"]\"\n    }).join(), \")}else{b.push(\",\n    facets.map(function(f) {\n      var e = f.slice()\n      e.reverse()\n      return \"[\" + e.map(function(v) {\n        return \"v\" + v\n      }) + \"]\"\n    }).join(),\n    \")}}});function \", funcName, \"(array,level){var verts=[],cells=[];contour(array,verts,cells,level);return {positions:verts,cells:cells};} return \", funcName, \";\")\n\n  for(var i=0; i<extraFuncs.length; ++i) {\n    code.push(extraFuncs[i].join(\"\"))\n  }\n\n  //Compile and link\n  var proc = new Function(\"genContour\", code.join(\"\"))\n  return proc(generateContourExtractor)\n}\n\n//1D case: Need to handle specially\nfunction mesh1D(array, level) {\n  var zc = zeroCrossings(array, level)\n  var n = zc.length\n  var npos = new Array(n)\n  var ncel = new Array(n)\n  for(var i=0; i<n; ++i) {\n    npos[i] = [ zc[i] ]\n    ncel[i] = [ i ]\n  }\n  return {\n    positions: npos,\n    cells: ncel\n  }\n}\n\nvar CACHE = {}\n\nfunction surfaceNets(array,level) {\n  if(array.dimension <= 0) {\n    return { positions: [], cells: [] }\n  } else if(array.dimension === 1) {\n    return mesh1D(array, level)\n  }\n  var typesig = array.order.join() + \"-\" + array.dtype\n  var proc = CACHE[typesig]\n  var level = (+level) || 0.0\n  if(!proc) {\n    proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype)\n  }\n  return proc(array,level)\n}"]},"metadata":{},"sourceType":"script"}