{"ast":null,"code":"'use strict';\n\nmodule.exports = boxIntersectWrapper;\n\nvar pool = require('typedarray-pool');\n\nvar sweep = require('./lib/sweep');\n\nvar boxIntersectIter = require('./lib/intersect');\n\nfunction boxEmpty(d, box) {\n  for (var j = 0; j < d; ++j) {\n    if (!(box[j] <= box[j + d])) {\n      return true;\n    }\n  }\n\n  return false;\n} //Unpack boxes into a flat typed array, remove empty boxes\n\n\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0;\n  var count = 0;\n\n  for (var i = 0, n = boxes.length; i < n; ++i) {\n    var b = boxes[i];\n\n    if (boxEmpty(d, b)) {\n      continue;\n    }\n\n    for (var j = 0; j < 2 * d; ++j) {\n      data[ptr++] = b[j];\n    }\n\n    ids[count++] = i;\n  }\n\n  return count;\n} //Perform type conversions, check bounds\n\n\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length;\n  var m = blue.length; //If either array is empty, then we can skip this whole thing\n\n  if (n <= 0 || m <= 0) {\n    return;\n  } //Compute dimension, if it is 0 then we skip\n\n\n  var d = red[0].length >>> 1;\n\n  if (d <= 0) {\n    return;\n  }\n\n  var retval; //Convert red boxes\n\n  var redList = pool.mallocDouble(2 * d * n);\n  var redIds = pool.mallocInt32(n);\n  n = convertBoxes(red, d, redList, redIds);\n\n  if (n > 0) {\n    if (d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n);\n      retval = sweep.sweepComplete(d, visit, 0, n, redList, redIds, 0, n, redList, redIds);\n    } else {\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2 * d * m);\n      var blueIds = pool.mallocInt32(m);\n      m = convertBoxes(blue, d, blueList, blueIds);\n\n      if (m > 0) {\n        sweep.init(n + m);\n\n        if (d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(d, visit, 0, n, redList, redIds, 0, m, blueList, blueIds);\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(d, visit, full, n, redList, redIds, m, blueList, blueIds);\n        }\n\n        pool.free(blueList);\n        pool.free(blueIds);\n      }\n    }\n\n    pool.free(redList);\n    pool.free(redIds);\n  }\n\n  return retval;\n}\n\nvar RESULT;\n\nfunction appendItem(i, j) {\n  RESULT.push([i, j]);\n}\n\nfunction intersectFullArray(x) {\n  RESULT = [];\n  boxIntersect(x, x, appendItem, true);\n  return RESULT;\n}\n\nfunction intersectBipartiteArray(x, y) {\n  RESULT = [];\n  boxIntersect(x, y, appendItem, false);\n  return RESULT;\n} //User-friendly wrapper, handle full input and no-visitor cases\n\n\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  var result;\n\n  switch (arguments.length) {\n    case 1:\n      return intersectFullArray(arg0);\n\n    case 2:\n      if (typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true);\n      } else {\n        return intersectBipartiteArray(arg0, arg1);\n      }\n\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false);\n\n    default:\n      throw new Error('box-intersect: Invalid arguments');\n  }\n}","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/box-intersect/index.js"],"names":["module","exports","boxIntersectWrapper","pool","require","sweep","boxIntersectIter","boxEmpty","d","box","j","convertBoxes","boxes","data","ids","ptr","count","i","n","length","b","boxIntersect","red","blue","visit","full","m","retval","redList","mallocDouble","redIds","mallocInt32","init","sweepComplete","blueList","blueIds","sweepBipartite","free","RESULT","appendItem","push","intersectFullArray","x","intersectBipartiteArray","y","arg0","arg1","arg2","result","arguments","Error"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = boxIntersectWrapper\n\nvar pool = require('typedarray-pool')\nvar sweep = require('./lib/sweep')\nvar boxIntersectIter = require('./lib/intersect')\n\nfunction boxEmpty(d, box) {\n  for(var j=0; j<d; ++j) {\n    if(!(box[j] <= box[j+d])) {\n      return true\n    }\n  }\n  return false\n}\n\n//Unpack boxes into a flat typed array, remove empty boxes\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0\n  var count = 0\n  for(var i=0, n=boxes.length; i<n; ++i) {\n    var b = boxes[i]\n    if(boxEmpty(d, b)) {\n      continue\n    }\n    for(var j=0; j<2*d; ++j) {\n      data[ptr++] = b[j]\n    }\n    ids[count++] = i\n  }\n  return count\n}\n\n//Perform type conversions, check bounds\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length\n  var m = blue.length\n\n  //If either array is empty, then we can skip this whole thing\n  if(n <= 0 || m <= 0) {\n    return\n  }\n\n  //Compute dimension, if it is 0 then we skip\n  var d = (red[0].length)>>>1\n  if(d <= 0) {\n    return\n  }\n\n  var retval\n\n  //Convert red boxes\n  var redList  = pool.mallocDouble(2*d*n)\n  var redIds   = pool.mallocInt32(n)\n  n = convertBoxes(red, d, redList, redIds)\n\n  if(n > 0) {\n    if(d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n)\n      retval = sweep.sweepComplete(\n        d, visit, \n        0, n, redList, redIds,\n        0, n, redList, redIds)\n    } else {\n\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2*d*m)\n      var blueIds  = pool.mallocInt32(m)\n      m = convertBoxes(blue, d, blueList, blueIds)\n\n      if(m > 0) {\n        sweep.init(n+m)\n\n        if(d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(\n            d, visit, \n            0, n, redList,  redIds,\n            0, m, blueList, blueIds)\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(\n            d, visit,    full,\n            n, redList,  redIds,\n            m, blueList, blueIds)\n        }\n\n        pool.free(blueList)\n        pool.free(blueIds)\n      }\n    }\n\n    pool.free(redList)\n    pool.free(redIds)\n  }\n\n  return retval\n}\n\n\nvar RESULT\n\nfunction appendItem(i,j) {\n  RESULT.push([i,j])\n}\n\nfunction intersectFullArray(x) {\n  RESULT = []\n  boxIntersect(x, x, appendItem, true)\n  return RESULT\n}\n\nfunction intersectBipartiteArray(x, y) {\n  RESULT = []\n  boxIntersect(x, y, appendItem, false)\n  return RESULT\n}\n\n//User-friendly wrapper, handle full input and no-visitor cases\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  var result\n  switch(arguments.length) {\n    case 1:\n      return intersectFullArray(arg0)\n    case 2:\n      if(typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true)\n      } else {\n        return intersectBipartiteArray(arg0, arg1)\n      }\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false)\n    default:\n      throw new Error('box-intersect: Invalid arguments')\n  }\n}"]},"metadata":{},"sourceType":"script"}