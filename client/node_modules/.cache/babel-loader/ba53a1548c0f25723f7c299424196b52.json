{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar dateTime2ms = Lib.dateTime2ms;\nvar incrementMonth = Lib.incrementMonth;\n\nvar constants = require('../../constants/numerical');\n\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\n\nmodule.exports = function alignPeriod(trace, ax, axLetter, vals) {\n  if (ax.type !== 'date') return vals;\n  var alignment = trace[axLetter + 'periodalignment'];\n  if (!alignment) return vals;\n  var period = trace[axLetter + 'period'];\n  var mPeriod;\n\n  if (isNumeric(period)) {\n    period = +period;\n    if (period <= 0) return vals;\n  } else if (typeof period === 'string' && period.charAt(0) === 'M') {\n    var n = +period.substring(1);\n\n    if (n > 0 && Math.round(n) === n) {\n      mPeriod = n;\n    } else return vals;\n  }\n\n  var calendar = ax.calendar;\n  var isStart = 'start' === alignment; // var isMiddle = 'middle' === alignment;\n\n  var isEnd = 'end' === alignment;\n  var period0 = trace[axLetter + 'period0'];\n  var base = dateTime2ms(period0, calendar) || 0;\n  var newVals = [];\n  var len = vals.length;\n\n  for (var i = 0; i < len; i++) {\n    var v = vals[i];\n    var nEstimated, startTime, endTime;\n\n    if (mPeriod) {\n      // guess at how many periods away from base we are\n      nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));\n      endTime = incrementMonth(base, mPeriod * nEstimated, calendar); // iterate to get the exact bounds before and after v\n      // there may be ways to make this faster, but most of the time\n      // we'll only execute each loop zero or one time.\n\n      while (endTime > v) {\n        endTime = incrementMonth(endTime, -mPeriod, calendar);\n      }\n\n      while (endTime <= v) {\n        endTime = incrementMonth(endTime, mPeriod, calendar);\n      } // now we know endTime is the boundary immediately after v\n      // so startTime is obtained by incrementing backward one period.\n\n\n      startTime = incrementMonth(endTime, -mPeriod, calendar);\n    } else {\n      // case of ms\n      nEstimated = Math.round((v - base) / period);\n      endTime = base + nEstimated * period;\n\n      while (endTime > v) {\n        endTime -= period;\n      }\n\n      while (endTime <= v) {\n        endTime += period;\n      }\n\n      startTime = endTime - period;\n    }\n\n    newVals[i] = isStart ? startTime : isEnd ? endTime : (startTime + endTime) / 2;\n  }\n\n  return newVals;\n};","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/plotly.js/src/plots/cartesian/align_period.js"],"names":["isNumeric","require","Lib","dateTime2ms","incrementMonth","constants","ONEAVGMONTH","module","exports","alignPeriod","trace","ax","axLetter","vals","type","alignment","period","mPeriod","charAt","n","substring","Math","round","calendar","isStart","isEnd","period0","base","newVals","len","length","i","v","nEstimated","startTime","endTime"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar dateTime2ms = Lib.dateTime2ms;\nvar incrementMonth = Lib.incrementMonth;\nvar constants = require('../../constants/numerical');\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\n\nmodule.exports = function alignPeriod(trace, ax, axLetter, vals) {\n    if(ax.type !== 'date') return vals;\n\n    var alignment = trace[axLetter + 'periodalignment'];\n    if(!alignment) return vals;\n\n    var period = trace[axLetter + 'period'];\n    var mPeriod;\n    if(isNumeric(period)) {\n        period = +period;\n        if(period <= 0) return vals;\n    } else if(typeof period === 'string' && period.charAt(0) === 'M') {\n        var n = +(period.substring(1));\n        if(n > 0 && Math.round(n) === n) {\n            mPeriod = n;\n        } else return vals;\n    }\n\n    var calendar = ax.calendar;\n\n    var isStart = 'start' === alignment;\n    // var isMiddle = 'middle' === alignment;\n    var isEnd = 'end' === alignment;\n\n    var period0 = trace[axLetter + 'period0'];\n    var base = dateTime2ms(period0, calendar) || 0;\n\n    var newVals = [];\n    var len = vals.length;\n    for(var i = 0; i < len; i++) {\n        var v = vals[i];\n\n        var nEstimated, startTime, endTime;\n        if(mPeriod) {\n            // guess at how many periods away from base we are\n            nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));\n            endTime = incrementMonth(base, mPeriod * nEstimated, calendar);\n\n            // iterate to get the exact bounds before and after v\n            // there may be ways to make this faster, but most of the time\n            // we'll only execute each loop zero or one time.\n            while(endTime > v) {\n                endTime = incrementMonth(endTime, -mPeriod, calendar);\n            }\n            while(endTime <= v) {\n                endTime = incrementMonth(endTime, mPeriod, calendar);\n            }\n\n            // now we know endTime is the boundary immediately after v\n            // so startTime is obtained by incrementing backward one period.\n            startTime = incrementMonth(endTime, -mPeriod, calendar);\n        } else { // case of ms\n            nEstimated = Math.round((v - base) / period);\n            endTime = base + nEstimated * period;\n\n            while(endTime > v) {\n                endTime -= period;\n            }\n            while(endTime <= v) {\n                endTime += period;\n            }\n\n            startTime = endTime - period;\n        }\n\n        newVals[i] = (\n            isStart ? startTime :\n            isEnd ? endTime :\n            (startTime + endTime) / 2\n        );\n    }\n    return newVals;\n};\n"]},"metadata":{},"sourceType":"script"}