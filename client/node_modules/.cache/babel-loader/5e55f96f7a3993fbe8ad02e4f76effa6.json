{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function getLegendData(calcdata, opts) {\n  var lgroupToTraces = {};\n  var lgroups = [];\n  var hasOneNonBlankGroup = false;\n  var slicesShown = {};\n  var lgroupi = 0;\n  var maxNameLength = 0;\n  var i, j;\n  var main = opts._main;\n\n  function addOneItem(legendGroup, legendItem) {\n    // each '' legend group is treated as a separate group\n    if (legendGroup === '' || !helpers.isGrouped(opts)) {\n      // TODO: check this against fullData legendgroups?\n      var uniqueGroup = '~~i' + lgroupi;\n      lgroups.push(uniqueGroup);\n      lgroupToTraces[uniqueGroup] = [[legendItem]];\n      lgroupi++;\n    } else if (lgroups.indexOf(legendGroup) === -1) {\n      lgroups.push(legendGroup);\n      hasOneNonBlankGroup = true;\n      lgroupToTraces[legendGroup] = [[legendItem]];\n    } else {\n      lgroupToTraces[legendGroup].push([legendItem]);\n    }\n  } // build an { legendgroup: [cd0, cd0], ... } object\n\n\n  for (i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var lgroup = trace.legendgroup;\n    if (main && (!trace.visible || !trace.showlegend)) continue;\n\n    if (Registry.traceIs(trace, 'pie-like')) {\n      if (!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n      for (j = 0; j < cd.length; j++) {\n        var labelj = cd[j].label;\n\n        if (!slicesShown[lgroup][labelj]) {\n          addOneItem(lgroup, {\n            label: labelj,\n            color: cd[j].color,\n            i: cd[j].i,\n            trace: trace,\n            pts: cd[j].pts\n          });\n          slicesShown[lgroup][labelj] = true;\n          maxNameLength = Math.max(maxNameLength, (labelj || '').length);\n        }\n      }\n    } else {\n      addOneItem(lgroup, cd0);\n      maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\n    }\n  } // won't draw a legend in this case\n\n\n  if (!lgroups.length) return []; // rearrange lgroupToTraces into a d3-friendly array of arrays\n\n  var lgroupsLength = lgroups.length;\n  var ltraces;\n  var legendData;\n\n  if (hasOneNonBlankGroup && helpers.isGrouped(opts)) {\n    legendData = new Array(lgroupsLength);\n\n    for (i = 0; i < lgroupsLength; i++) {\n      ltraces = lgroupToTraces[lgroups[i]];\n      legendData[i] = helpers.isReversed(opts) ? ltraces.reverse() : ltraces;\n    }\n  } else {\n    // collapse all groups into one if all groups are blank\n    legendData = [new Array(lgroupsLength)];\n\n    for (i = 0; i < lgroupsLength; i++) {\n      ltraces = lgroupToTraces[lgroups[i]][0];\n      legendData[0][helpers.isReversed(opts) ? lgroupsLength - i - 1 : i] = ltraces;\n    }\n\n    lgroupsLength = 1;\n  } // number of legend groups - needed in legend/draw.js\n\n\n  opts._lgroupsLength = lgroupsLength; // maximum name/label length - needed in legend/draw.js\n\n  opts._maxNameLength = maxNameLength;\n  return legendData;\n};","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/plotly.js/src/components/legend/get_legend_data.js"],"names":["Registry","require","helpers","module","exports","getLegendData","calcdata","opts","lgroupToTraces","lgroups","hasOneNonBlankGroup","slicesShown","lgroupi","maxNameLength","i","j","main","_main","addOneItem","legendGroup","legendItem","isGrouped","uniqueGroup","push","indexOf","length","cd","cd0","trace","lgroup","legendgroup","visible","showlegend","traceIs","labelj","label","color","pts","Math","max","name","lgroupsLength","ltraces","legendData","Array","isReversed","reverse","_lgroupsLength","_maxNameLength"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar helpers = require('./helpers');\n\nmodule.exports = function getLegendData(calcdata, opts) {\n    var lgroupToTraces = {};\n    var lgroups = [];\n    var hasOneNonBlankGroup = false;\n    var slicesShown = {};\n    var lgroupi = 0;\n    var maxNameLength = 0;\n    var i, j;\n    var main = opts._main;\n\n    function addOneItem(legendGroup, legendItem) {\n        // each '' legend group is treated as a separate group\n        if(legendGroup === '' || !helpers.isGrouped(opts)) {\n            // TODO: check this against fullData legendgroups?\n            var uniqueGroup = '~~i' + lgroupi;\n            lgroups.push(uniqueGroup);\n            lgroupToTraces[uniqueGroup] = [[legendItem]];\n            lgroupi++;\n        } else if(lgroups.indexOf(legendGroup) === -1) {\n            lgroups.push(legendGroup);\n            hasOneNonBlankGroup = true;\n            lgroupToTraces[legendGroup] = [[legendItem]];\n        } else {\n            lgroupToTraces[legendGroup].push([legendItem]);\n        }\n    }\n\n    // build an { legendgroup: [cd0, cd0], ... } object\n    for(i = 0; i < calcdata.length; i++) {\n        var cd = calcdata[i];\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n        var lgroup = trace.legendgroup;\n\n        if(main && (!trace.visible || !trace.showlegend)) continue;\n\n        if(Registry.traceIs(trace, 'pie-like')) {\n            if(!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n            for(j = 0; j < cd.length; j++) {\n                var labelj = cd[j].label;\n\n                if(!slicesShown[lgroup][labelj]) {\n                    addOneItem(lgroup, {\n                        label: labelj,\n                        color: cd[j].color,\n                        i: cd[j].i,\n                        trace: trace,\n                        pts: cd[j].pts\n                    });\n\n                    slicesShown[lgroup][labelj] = true;\n                    maxNameLength = Math.max(maxNameLength, (labelj || '').length);\n                }\n            }\n        } else {\n            addOneItem(lgroup, cd0);\n            maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\n        }\n    }\n\n    // won't draw a legend in this case\n    if(!lgroups.length) return [];\n\n    // rearrange lgroupToTraces into a d3-friendly array of arrays\n    var lgroupsLength = lgroups.length;\n    var ltraces;\n    var legendData;\n\n    if(hasOneNonBlankGroup && helpers.isGrouped(opts)) {\n        legendData = new Array(lgroupsLength);\n\n        for(i = 0; i < lgroupsLength; i++) {\n            ltraces = lgroupToTraces[lgroups[i]];\n            legendData[i] = helpers.isReversed(opts) ? ltraces.reverse() : ltraces;\n        }\n    } else {\n        // collapse all groups into one if all groups are blank\n        legendData = [new Array(lgroupsLength)];\n\n        for(i = 0; i < lgroupsLength; i++) {\n            ltraces = lgroupToTraces[lgroups[i]][0];\n            legendData[0][helpers.isReversed(opts) ? lgroupsLength - i - 1 : i] = ltraces;\n        }\n        lgroupsLength = 1;\n    }\n\n    // number of legend groups - needed in legend/draw.js\n    opts._lgroupsLength = lgroupsLength;\n    // maximum name/label length - needed in legend/draw.js\n    opts._maxNameLength = maxNameLength;\n\n    return legendData;\n};\n"]},"metadata":{},"sourceType":"script"}