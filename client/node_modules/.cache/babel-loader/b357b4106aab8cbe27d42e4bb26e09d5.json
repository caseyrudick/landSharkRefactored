{"ast":null,"code":"'use strict';\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n **/\n\nvar SIZE_HEADER = 4 + 4; // 8\n\nvar FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n *\n **/\n\nvar ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n\nfunction isICNS(buffer) {\n  return 'icns' === buffer.toString('ascii', 0, 4);\n}\n\nvar ICON_TYPE_SIZE = {\n  ICON: 32,\n  'ICN#': 32,\n  // m => 16 x 16\n  'icm#': 16,\n  icm4: 16,\n  icm8: 16,\n  // s => 16 x 16\n  'ics#': 16,\n  ics4: 16,\n  ics8: 16,\n  is32: 16,\n  s8mk: 16,\n  icp4: 16,\n  // l => 32 x 32\n  icl4: 32,\n  icl8: 32,\n  il32: 32,\n  l8mk: 32,\n  icp5: 32,\n  ic11: 32,\n  // h => 48 x 48\n  ich4: 48,\n  ich8: 48,\n  ih32: 48,\n  h8mk: 48,\n  // . => 64 x 64\n  icp6: 64,\n  ic12: 32,\n  // t => 128 x 128\n  it32: 128,\n  t8mk: 128,\n  ic07: 128,\n  // . => 256 x 256\n  ic08: 256,\n  ic13: 256,\n  // . => 512 x 512\n  ic09: 512,\n  ic14: 512,\n  // . => 1024 x 1024\n  ic10: 1024\n};\n\nfunction readImageHeader(buffer, imageOffset) {\n  var imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET; // returns [type, length]\n\n  return [buffer.toString('ascii', imageOffset, imageLengthOffset), buffer.readUInt32BE(imageLengthOffset)];\n}\n\nfunction getImageSize(type) {\n  var size = ICON_TYPE_SIZE[type];\n  return {\n    width: size,\n    height: size,\n    type: type\n  };\n}\n\nfunction calculate(buffer) {\n  var bufferLength = buffer.length,\n      imageOffset = SIZE_HEADER,\n      fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET),\n      imageHeader,\n      imageSize,\n      result;\n  imageHeader = readImageHeader(buffer, imageOffset);\n  imageSize = getImageSize(imageHeader[0]);\n  imageOffset += imageHeader[1];\n\n  if (imageOffset === fileLength) {\n    return imageSize;\n  }\n\n  result = {\n    width: imageSize.width,\n    height: imageSize.height,\n    images: [imageSize]\n  };\n\n  while (imageOffset < fileLength && imageOffset < bufferLength) {\n    imageHeader = readImageHeader(buffer, imageOffset);\n    imageSize = getImageSize(imageHeader[0]);\n    imageOffset += imageHeader[1];\n    result.images.push(imageSize);\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  'detect': isICNS,\n  'calculate': calculate\n};","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/image-size/lib/types/icns.js"],"names":["SIZE_HEADER","FILE_LENGTH_OFFSET","ENTRY_LENGTH_OFFSET","isICNS","buffer","toString","ICON_TYPE_SIZE","ICON","icm4","icm8","ics4","ics8","is32","s8mk","icp4","icl4","icl8","il32","l8mk","icp5","ic11","ich4","ich8","ih32","h8mk","icp6","ic12","it32","t8mk","ic07","ic08","ic13","ic09","ic14","ic10","readImageHeader","imageOffset","imageLengthOffset","readUInt32BE","getImageSize","type","size","width","height","calculate","bufferLength","length","fileLength","imageHeader","imageSize","result","images","push","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n **/\nvar SIZE_HEADER = 4 + 4; // 8\nvar FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n *\n **/\nvar ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n\nfunction isICNS (buffer) {\n  return ('icns' === buffer.toString('ascii', 0, 4));\n}\n\nvar ICON_TYPE_SIZE = {\n  ICON: 32,\n  'ICN#': 32,\n  // m => 16 x 16\n  'icm#': 16,\n  icm4: 16,\n  icm8: 16,\n  // s => 16 x 16\n  'ics#': 16,\n  ics4: 16,\n  ics8: 16,\n  is32: 16,\n  s8mk: 16,\n  icp4: 16,\n  // l => 32 x 32\n  icl4: 32,\n  icl8: 32,\n  il32: 32,\n  l8mk: 32,\n  icp5: 32,\n  ic11: 32,\n  // h => 48 x 48\n  ich4: 48,\n  ich8: 48,\n  ih32: 48,\n  h8mk: 48,\n  // . => 64 x 64\n  icp6: 64,\n  ic12: 32,\n  // t => 128 x 128\n  it32: 128,\n  t8mk: 128,\n  ic07: 128,\n  // . => 256 x 256\n  ic08: 256,\n  ic13: 256,\n  // . => 512 x 512\n  ic09: 512,\n  ic14: 512,\n  // . => 1024 x 1024\n  ic10: 1024,\n};\n\nfunction readImageHeader(buffer, imageOffset) {\n  var imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n  // returns [type, length]\n  return [\n    buffer.toString('ascii', imageOffset, imageLengthOffset),\n    buffer.readUInt32BE(imageLengthOffset)\n  ];\n}\n\nfunction getImageSize(type) {\n  var size = ICON_TYPE_SIZE[type];\n  return { width: size, height: size, type: type };\n}\n\nfunction calculate (buffer) {\n  var\n    bufferLength = buffer.length,\n    imageOffset = SIZE_HEADER,\n    fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET),\n    imageHeader,\n    imageSize,\n    result;\n\n  imageHeader = readImageHeader(buffer, imageOffset);\n  imageSize = getImageSize(imageHeader[0]);\n  imageOffset += imageHeader[1];\n\n  if (imageOffset === fileLength) {\n    return imageSize;\n  }\n  \n  result = {\n    width: imageSize.width,\n    height: imageSize.height,\n    images: [imageSize]\n  };\n  \n  while (imageOffset < fileLength && imageOffset < bufferLength) {\n    imageHeader = readImageHeader(buffer, imageOffset);\n    imageSize = getImageSize(imageHeader[0]);\n    imageOffset += imageHeader[1];\n    result.images.push(imageSize);\n  }\n  \n  return result;\n}\n\nmodule.exports = {\n  'detect': isICNS,\n  'calculate': calculate\n};\n"]},"metadata":{},"sourceType":"script"}