{"ast":null,"code":"'use strict';\n\nmodule.exports = createAttributeWrapper;\n\nvar GLError = require(\"./GLError\");\n\nfunction ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc) {\n  this._gl = gl;\n  this._wrapper = wrapper;\n  this._index = index;\n  this._locations = locations;\n  this._dimension = dimension;\n  this._constFunc = constFunc;\n}\n\nvar proto = ShaderAttribute.prototype;\n\nproto.pointer = function setAttribPointer(type, normalized, stride, offset) {\n  var self = this;\n  var gl = self._gl;\n  var location = self._locations[self._index];\n  gl.vertexAttribPointer(location, self._dimension, type || gl.FLOAT, !!normalized, stride || 0, offset || 0);\n  gl.enableVertexAttribArray(location);\n};\n\nproto.set = function (x0, x1, x2, x3) {\n  return this._constFunc(this._locations[this._index], x0, x1, x2, x3);\n};\n\nObject.defineProperty(proto, 'location', {\n  get: function () {\n    return this._locations[this._index];\n  },\n  set: function (v) {\n    if (v !== this._locations[this._index]) {\n      this._locations[this._index] = v | 0;\n      this._wrapper.program = null;\n    }\n\n    return v | 0;\n  }\n}); //Adds a vector attribute to obj\n\nfunction addVectorAttribute(gl, wrapper, index, locations, dimension, obj, name) {\n  //Construct constant function\n  var constFuncArgs = ['gl', 'v'];\n  var varNames = [];\n\n  for (var i = 0; i < dimension; ++i) {\n    constFuncArgs.push('x' + i);\n    varNames.push('x' + i);\n  }\n\n  constFuncArgs.push('if(x0.length===void 0){return gl.vertexAttrib' + dimension + 'f(v,' + varNames.join() + ')}else{return gl.vertexAttrib' + dimension + 'fv(v,x0)}');\n  var constFunc = Function.apply(null, constFuncArgs); //Create attribute wrapper\n\n  var attr = new ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc); //Create accessor\n\n  Object.defineProperty(obj, name, {\n    set: function (x) {\n      gl.disableVertexAttribArray(locations[index]);\n      constFunc(gl, locations[index], x);\n      return x;\n    },\n    get: function () {\n      return attr;\n    },\n    enumerable: true\n  });\n}\n\nfunction addMatrixAttribute(gl, wrapper, index, locations, dimension, obj, name) {\n  var parts = new Array(dimension);\n  var attrs = new Array(dimension);\n\n  for (var i = 0; i < dimension; ++i) {\n    addVectorAttribute(gl, wrapper, index[i], locations, dimension, parts, i);\n    attrs[i] = parts[i];\n  }\n\n  Object.defineProperty(parts, 'location', {\n    set: function (v) {\n      if (Array.isArray(v)) {\n        for (var i = 0; i < dimension; ++i) {\n          attrs[i].location = v[i];\n        }\n      } else {\n        for (var i = 0; i < dimension; ++i) {\n          attrs[i].location = v + i;\n        }\n      }\n\n      return v;\n    },\n    get: function () {\n      var result = new Array(dimension);\n\n      for (var i = 0; i < dimension; ++i) {\n        result[i] = locations[index[i]];\n      }\n\n      return result;\n    },\n    enumerable: true\n  });\n\n  parts.pointer = function (type, normalized, stride, offset) {\n    type = type || gl.FLOAT;\n    normalized = !!normalized;\n    stride = stride || dimension * dimension;\n    offset = offset || 0;\n\n    for (var i = 0; i < dimension; ++i) {\n      var location = locations[index[i]];\n      gl.vertexAttribPointer(location, dimension, type, normalized, stride, offset + i * dimension);\n      gl.enableVertexAttribArray(location);\n    }\n  };\n\n  var scratch = new Array(dimension);\n  var vertexAttrib = gl['vertexAttrib' + dimension + 'fv'];\n  Object.defineProperty(obj, name, {\n    set: function (x) {\n      for (var i = 0; i < dimension; ++i) {\n        var loc = locations[index[i]];\n        gl.disableVertexAttribArray(loc);\n\n        if (Array.isArray(x[0])) {\n          vertexAttrib.call(gl, loc, x[i]);\n        } else {\n          for (var j = 0; j < dimension; ++j) {\n            scratch[j] = x[dimension * i + j];\n          }\n\n          vertexAttrib.call(gl, loc, scratch);\n        }\n      }\n\n      return x;\n    },\n    get: function () {\n      return parts;\n    },\n    enumerable: true\n  });\n} //Create shims for attributes\n\n\nfunction createAttributeWrapper(gl, wrapper, attributes, locations) {\n  var obj = {};\n\n  for (var i = 0, n = attributes.length; i < n; ++i) {\n    var a = attributes[i];\n    var name = a.name;\n    var type = a.type;\n    var locs = a.locations;\n\n    switch (type) {\n      case 'bool':\n      case 'int':\n      case 'float':\n        addVectorAttribute(gl, wrapper, locs[0], locations, 1, obj, name);\n        break;\n\n      default:\n        if (type.indexOf('vec') >= 0) {\n          var d = type.charCodeAt(type.length - 1) - 48;\n\n          if (d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type);\n          }\n\n          addVectorAttribute(gl, wrapper, locs[0], locations, d, obj, name);\n        } else if (type.indexOf('mat') >= 0) {\n          var d = type.charCodeAt(type.length - 1) - 48;\n\n          if (d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type);\n          }\n\n          addMatrixAttribute(gl, wrapper, locs, locations, d, obj, name);\n        } else {\n          throw new GLError('', 'Unknown data type for attribute ' + name + ': ' + type);\n        }\n\n        break;\n    }\n  }\n\n  return obj;\n}","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/gl-shader/lib/create-attributes.js"],"names":["module","exports","createAttributeWrapper","GLError","require","ShaderAttribute","gl","wrapper","index","locations","dimension","constFunc","_gl","_wrapper","_index","_locations","_dimension","_constFunc","proto","prototype","pointer","setAttribPointer","type","normalized","stride","offset","self","location","vertexAttribPointer","FLOAT","enableVertexAttribArray","set","x0","x1","x2","x3","Object","defineProperty","get","v","program","addVectorAttribute","obj","name","constFuncArgs","varNames","i","push","join","Function","apply","attr","x","disableVertexAttribArray","enumerable","addMatrixAttribute","parts","Array","attrs","isArray","result","scratch","vertexAttrib","loc","call","j","attributes","n","length","a","locs","indexOf","d","charCodeAt"],"mappings":"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","sourcesContent":["'use strict'\n\nmodule.exports = createAttributeWrapper\n\nvar GLError = require(\"./GLError\")\n\nfunction ShaderAttribute(\n    gl\n  , wrapper\n  , index\n  , locations\n  , dimension\n  , constFunc) {\n  this._gl        = gl\n  this._wrapper   = wrapper\n  this._index     = index\n  this._locations = locations\n  this._dimension = dimension\n  this._constFunc = constFunc\n}\n\nvar proto = ShaderAttribute.prototype\n\nproto.pointer = function setAttribPointer(\n    type\n  , normalized\n  , stride\n  , offset) {\n\n  var self      = this\n  var gl        = self._gl\n  var location  = self._locations[self._index]\n\n  gl.vertexAttribPointer(\n      location\n    , self._dimension\n    , type || gl.FLOAT\n    , !!normalized\n    , stride || 0\n    , offset || 0)\n  gl.enableVertexAttribArray(location)\n}\n\nproto.set = function(x0, x1, x2, x3) {\n  return this._constFunc(this._locations[this._index], x0, x1, x2, x3)\n}\n\nObject.defineProperty(proto, 'location', {\n  get: function() {\n    return this._locations[this._index]\n  }\n  , set: function(v) {\n    if(v !== this._locations[this._index]) {\n      this._locations[this._index] = v|0\n      this._wrapper.program = null\n    }\n    return v|0\n  }\n})\n\n//Adds a vector attribute to obj\nfunction addVectorAttribute(\n    gl\n  , wrapper\n  , index\n  , locations\n  , dimension\n  , obj\n  , name) {\n\n  //Construct constant function\n  var constFuncArgs = [ 'gl', 'v' ]\n  var varNames = []\n  for(var i=0; i<dimension; ++i) {\n    constFuncArgs.push('x'+i)\n    varNames.push('x'+i)\n  }\n  constFuncArgs.push(\n    'if(x0.length===void 0){return gl.vertexAttrib' +\n    dimension + 'f(v,' +\n    varNames.join() +\n    ')}else{return gl.vertexAttrib' +\n    dimension +\n    'fv(v,x0)}')\n  var constFunc = Function.apply(null, constFuncArgs)\n\n  //Create attribute wrapper\n  var attr = new ShaderAttribute(\n      gl\n    , wrapper\n    , index\n    , locations\n    , dimension\n    , constFunc)\n\n  //Create accessor\n  Object.defineProperty(obj, name, {\n    set: function(x) {\n      gl.disableVertexAttribArray(locations[index])\n      constFunc(gl, locations[index], x)\n      return x\n    }\n    , get: function() {\n      return attr\n    }\n    , enumerable: true\n  })\n}\n\nfunction addMatrixAttribute(\n    gl\n  , wrapper\n  , index\n  , locations\n  , dimension\n  , obj\n  , name) {\n\n  var parts = new Array(dimension)\n  var attrs = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    addVectorAttribute(\n        gl\n      , wrapper\n      , index[i]\n      , locations\n      , dimension\n      , parts\n      , i)\n    attrs[i] = parts[i]\n  }\n\n  Object.defineProperty(parts, 'location', {\n    set: function(v) {\n      if(Array.isArray(v)) {\n        for(var i=0; i<dimension; ++i) {\n          attrs[i].location = v[i]\n        }\n      } else {\n        for(var i=0; i<dimension; ++i) {\n          attrs[i].location = v + i\n        }\n      }\n      return v\n    }\n    , get: function() {\n      var result = new Array(dimension)\n      for(var i=0; i<dimension; ++i) {\n        result[i] = locations[index[i]]\n      }\n      return result\n    }\n    , enumerable: true\n  })\n\n  parts.pointer = function(type, normalized, stride, offset) {\n    type       = type || gl.FLOAT\n    normalized = !!normalized\n    stride     = stride || (dimension * dimension)\n    offset     = offset || 0\n    for(var i=0; i<dimension; ++i) {\n      var location = locations[index[i]]\n      gl.vertexAttribPointer(\n            location\n          , dimension\n          , type\n          , normalized\n          , stride\n          , offset + i * dimension)\n      gl.enableVertexAttribArray(location)\n    }\n  }\n\n  var scratch = new Array(dimension)\n  var vertexAttrib = gl['vertexAttrib' + dimension + 'fv']\n\n  Object.defineProperty(obj, name, {\n    set: function(x) {\n      for(var i=0; i<dimension; ++i) {\n        var loc = locations[index[i]]\n        gl.disableVertexAttribArray(loc)\n        if(Array.isArray(x[0])) {\n          vertexAttrib.call(gl, loc, x[i])\n        } else {\n          for(var j=0; j<dimension; ++j) {\n            scratch[j] = x[dimension*i + j]\n          }\n          vertexAttrib.call(gl, loc, scratch)\n        }\n      }\n      return x\n    }\n    , get: function() {\n      return parts\n    }\n    , enumerable: true\n  })\n}\n\n//Create shims for attributes\nfunction createAttributeWrapper(\n    gl\n  , wrapper\n  , attributes\n  , locations) {\n\n  var obj = {}\n  for(var i=0, n=attributes.length; i<n; ++i) {\n\n    var a = attributes[i]\n    var name = a.name\n    var type = a.type\n    var locs = a.locations\n\n    switch(type) {\n      case 'bool':\n      case 'int':\n      case 'float':\n        addVectorAttribute(\n            gl\n          , wrapper\n          , locs[0]\n          , locations\n          , 1\n          , obj\n          , name)\n      break\n\n      default:\n        if(type.indexOf('vec') >= 0) {\n          var d = type.charCodeAt(type.length-1) - 48\n          if(d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type)\n          }\n          addVectorAttribute(\n              gl\n            , wrapper\n            , locs[0]\n            , locations\n            , d\n            , obj\n            , name)\n        } else if(type.indexOf('mat') >= 0) {\n          var d = type.charCodeAt(type.length-1) - 48\n          if(d < 2 || d > 4) {\n            throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type)\n          }\n          addMatrixAttribute(\n              gl\n            , wrapper\n            , locs\n            , locations\n            , d\n            , obj\n            , name)\n        } else {\n          throw new GLError('', 'Unknown data type for attribute ' + name + ': ' + type)\n        }\n      break\n    }\n  }\n  return obj\n}\n"]},"metadata":{},"sourceType":"script"}