{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar SHOWISOLATETIP = true;\n\nmodule.exports = function handleClick(g, gd, numClicks) {\n  var fullLayout = gd._fullLayout;\n  if (gd._dragged || gd._editing) return;\n  var itemClick = fullLayout.legend.itemclick;\n  var itemDoubleClick = fullLayout.legend.itemdoubleclick;\n\n  if (numClicks === 1 && itemClick === 'toggle' && itemDoubleClick === 'toggleothers' && SHOWISOLATETIP && gd.data && gd._context.showTips) {\n    Lib.notifier(Lib._(gd, 'Double-click on legend to isolate one trace'), 'long');\n    SHOWISOLATETIP = false;\n  } else {\n    SHOWISOLATETIP = false;\n  }\n\n  var mode;\n  if (numClicks === 1) mode = itemClick;else if (numClicks === 2) mode = itemDoubleClick;\n  if (!mode) return;\n  var hiddenSlices = fullLayout.hiddenlabels ? fullLayout.hiddenlabels.slice() : [];\n  var legendItem = g.data()[0][0];\n  var fullData = gd._fullData;\n  var fullTrace = legendItem.trace;\n  var legendgroup = fullTrace.legendgroup;\n  var i, j, kcont, key, keys, val;\n  var attrUpdate = {};\n  var attrIndices = [];\n  var carrs = [];\n  var carrIdx = [];\n\n  function insertUpdate(traceIndex, key, value) {\n    var attrIndex = attrIndices.indexOf(traceIndex);\n    var valueArray = attrUpdate[key];\n\n    if (!valueArray) {\n      valueArray = attrUpdate[key] = [];\n    }\n\n    if (attrIndices.indexOf(traceIndex) === -1) {\n      attrIndices.push(traceIndex);\n      attrIndex = attrIndices.length - 1;\n    }\n\n    valueArray[attrIndex] = value;\n    return attrIndex;\n  }\n\n  function setVisibility(fullTrace, visibility) {\n    var fullInput = fullTrace._fullInput;\n\n    if (Registry.hasTransform(fullInput, 'groupby')) {\n      var kcont = carrs[fullInput.index];\n\n      if (!kcont) {\n        var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n        var lastGroupbyIndex = groupbyIndices[groupbyIndices.length - 1];\n        kcont = Lib.keyedContainer(fullInput, 'transforms[' + lastGroupbyIndex + '].styles', 'target', 'value.visible');\n        carrs[fullInput.index] = kcont;\n      }\n\n      var curState = kcont.get(fullTrace._group); // If not specified, assume visible. This happens if there are other style\n      // properties set for a group but not the visibility. There are many similar\n      // ways to do this (e.g. why not just `curState = fullTrace.visible`??? The\n      // answer is: because it breaks other things like groupby trace names in\n      // subtle ways.)\n\n      if (curState === undefined) {\n        curState = true;\n      }\n\n      if (curState !== false) {\n        // true -> legendonly. All others toggle to true:\n        kcont.set(fullTrace._group, visibility);\n      }\n\n      carrIdx[fullInput.index] = insertUpdate(fullInput.index, 'visible', fullInput.visible === false ? false : true);\n    } else {\n      // false -> false (not possible since will not be visible in legend)\n      // true -> legendonly\n      // legendonly -> true\n      var nextVisibility = fullInput.visible === false ? false : visibility;\n      insertUpdate(fullInput.index, 'visible', nextVisibility);\n    }\n  }\n\n  if (Registry.traceIs(fullTrace, 'pie-like')) {\n    var thisLabel = legendItem.label;\n    var thisLabelIndex = hiddenSlices.indexOf(thisLabel);\n\n    if (mode === 'toggle') {\n      if (thisLabelIndex === -1) hiddenSlices.push(thisLabel);else hiddenSlices.splice(thisLabelIndex, 1);\n    } else if (mode === 'toggleothers') {\n      hiddenSlices = [];\n      gd.calcdata[0].forEach(function (d) {\n        if (thisLabel !== d.label) {\n          hiddenSlices.push(d.label);\n        }\n      });\n\n      if (gd._fullLayout.hiddenlabels && gd._fullLayout.hiddenlabels.length === hiddenSlices.length && thisLabelIndex === -1) {\n        hiddenSlices = [];\n      }\n    }\n\n    Registry.call('_guiRelayout', gd, 'hiddenlabels', hiddenSlices);\n  } else {\n    var hasLegendgroup = legendgroup && legendgroup.length;\n    var traceIndicesInGroup = [];\n    var tracei;\n\n    if (hasLegendgroup) {\n      for (i = 0; i < fullData.length; i++) {\n        tracei = fullData[i];\n        if (!tracei.visible) continue;\n\n        if (tracei.legendgroup === legendgroup) {\n          traceIndicesInGroup.push(i);\n        }\n      }\n    }\n\n    if (mode === 'toggle') {\n      var nextVisibility;\n\n      switch (fullTrace.visible) {\n        case true:\n          nextVisibility = 'legendonly';\n          break;\n\n        case false:\n          nextVisibility = false;\n          break;\n\n        case 'legendonly':\n          nextVisibility = true;\n          break;\n      }\n\n      if (hasLegendgroup) {\n        for (i = 0; i < fullData.length; i++) {\n          if (fullData[i].visible !== false && fullData[i].legendgroup === legendgroup) {\n            setVisibility(fullData[i], nextVisibility);\n          }\n        }\n      } else {\n        setVisibility(fullTrace, nextVisibility);\n      }\n    } else if (mode === 'toggleothers') {\n      // Compute the clicked index. expandedIndex does what we want for expanded traces\n      // but also culls hidden traces. That means we have some work to do.\n      var isClicked, isInGroup, notInLegend, otherState;\n      var isIsolated = true;\n\n      for (i = 0; i < fullData.length; i++) {\n        isClicked = fullData[i] === fullTrace;\n        notInLegend = fullData[i].showlegend !== true;\n        if (isClicked || notInLegend) continue;\n        isInGroup = hasLegendgroup && fullData[i].legendgroup === legendgroup;\n\n        if (!isInGroup && fullData[i].visible === true && !Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n          isIsolated = false;\n          break;\n        }\n      }\n\n      for (i = 0; i < fullData.length; i++) {\n        // False is sticky; we don't change it.\n        if (fullData[i].visible === false) continue;\n\n        if (Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n          continue;\n        }\n\n        switch (fullTrace.visible) {\n          case 'legendonly':\n            setVisibility(fullData[i], true);\n            break;\n\n          case true:\n            otherState = isIsolated ? true : 'legendonly';\n            isClicked = fullData[i] === fullTrace; // N.B. consider traces that have a set legendgroup as toggleable\n\n            notInLegend = fullData[i].showlegend !== true && !fullData[i].legendgroup;\n            isInGroup = isClicked || hasLegendgroup && fullData[i].legendgroup === legendgroup;\n            setVisibility(fullData[i], isInGroup || notInLegend ? true : otherState);\n            break;\n        }\n      }\n    }\n\n    for (i = 0; i < carrs.length; i++) {\n      kcont = carrs[i];\n      if (!kcont) continue;\n      var update = kcont.constructUpdate();\n      var updateKeys = Object.keys(update);\n\n      for (j = 0; j < updateKeys.length; j++) {\n        key = updateKeys[j];\n        val = attrUpdate[key] = attrUpdate[key] || [];\n        val[carrIdx[i]] = update[key];\n      }\n    } // The length of the value arrays should be equal and any unspecified\n    // values should be explicitly undefined for them to get properly culled\n    // as updates and not accidentally reset to the default value. This fills\n    // out sparse arrays with the required number of undefined values:\n\n\n    keys = Object.keys(attrUpdate);\n\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n\n      for (j = 0; j < attrIndices.length; j++) {\n        // Use hasOwnPropety to protect against falsey values:\n        if (!attrUpdate[key].hasOwnProperty(j)) {\n          attrUpdate[key][j] = undefined;\n        }\n      }\n    }\n\n    Registry.call('_guiRestyle', gd, attrUpdate, attrIndices);\n  }\n};","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/plotly.js/src/components/legend/handle_click.js"],"names":["Lib","require","Registry","SHOWISOLATETIP","module","exports","handleClick","g","gd","numClicks","fullLayout","_fullLayout","_dragged","_editing","itemClick","legend","itemclick","itemDoubleClick","itemdoubleclick","data","_context","showTips","notifier","_","mode","hiddenSlices","hiddenlabels","slice","legendItem","fullData","_fullData","fullTrace","trace","legendgroup","i","j","kcont","key","keys","val","attrUpdate","attrIndices","carrs","carrIdx","insertUpdate","traceIndex","value","attrIndex","indexOf","valueArray","push","length","setVisibility","visibility","fullInput","_fullInput","hasTransform","index","groupbyIndices","getTransformIndices","lastGroupbyIndex","keyedContainer","curState","get","_group","undefined","set","visible","nextVisibility","traceIs","thisLabel","label","thisLabelIndex","splice","calcdata","forEach","d","call","hasLegendgroup","traceIndicesInGroup","tracei","isClicked","isInGroup","notInLegend","otherState","isIsolated","showlegend","update","constructUpdate","updateKeys","Object","hasOwnProperty"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\n\nvar SHOWISOLATETIP = true;\n\nmodule.exports = function handleClick(g, gd, numClicks) {\n    var fullLayout = gd._fullLayout;\n\n    if(gd._dragged || gd._editing) return;\n\n    var itemClick = fullLayout.legend.itemclick;\n    var itemDoubleClick = fullLayout.legend.itemdoubleclick;\n\n    if(numClicks === 1 && itemClick === 'toggle' && itemDoubleClick === 'toggleothers' &&\n        SHOWISOLATETIP && gd.data && gd._context.showTips\n    ) {\n        Lib.notifier(Lib._(gd, 'Double-click on legend to isolate one trace'), 'long');\n        SHOWISOLATETIP = false;\n    } else {\n        SHOWISOLATETIP = false;\n    }\n\n    var mode;\n    if(numClicks === 1) mode = itemClick;\n    else if(numClicks === 2) mode = itemDoubleClick;\n    if(!mode) return;\n\n    var hiddenSlices = fullLayout.hiddenlabels ?\n        fullLayout.hiddenlabels.slice() :\n        [];\n\n    var legendItem = g.data()[0][0];\n    var fullData = gd._fullData;\n    var fullTrace = legendItem.trace;\n    var legendgroup = fullTrace.legendgroup;\n\n    var i, j, kcont, key, keys, val;\n    var attrUpdate = {};\n    var attrIndices = [];\n    var carrs = [];\n    var carrIdx = [];\n\n    function insertUpdate(traceIndex, key, value) {\n        var attrIndex = attrIndices.indexOf(traceIndex);\n        var valueArray = attrUpdate[key];\n        if(!valueArray) {\n            valueArray = attrUpdate[key] = [];\n        }\n\n        if(attrIndices.indexOf(traceIndex) === -1) {\n            attrIndices.push(traceIndex);\n            attrIndex = attrIndices.length - 1;\n        }\n\n        valueArray[attrIndex] = value;\n\n        return attrIndex;\n    }\n\n    function setVisibility(fullTrace, visibility) {\n        var fullInput = fullTrace._fullInput;\n        if(Registry.hasTransform(fullInput, 'groupby')) {\n            var kcont = carrs[fullInput.index];\n            if(!kcont) {\n                var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n                var lastGroupbyIndex = groupbyIndices[groupbyIndices.length - 1];\n                kcont = Lib.keyedContainer(fullInput, 'transforms[' + lastGroupbyIndex + '].styles', 'target', 'value.visible');\n                carrs[fullInput.index] = kcont;\n            }\n\n            var curState = kcont.get(fullTrace._group);\n\n            // If not specified, assume visible. This happens if there are other style\n            // properties set for a group but not the visibility. There are many similar\n            // ways to do this (e.g. why not just `curState = fullTrace.visible`??? The\n            // answer is: because it breaks other things like groupby trace names in\n            // subtle ways.)\n            if(curState === undefined) {\n                curState = true;\n            }\n\n            if(curState !== false) {\n                // true -> legendonly. All others toggle to true:\n                kcont.set(fullTrace._group, visibility);\n            }\n            carrIdx[fullInput.index] = insertUpdate(fullInput.index, 'visible', fullInput.visible === false ? false : true);\n        } else {\n            // false -> false (not possible since will not be visible in legend)\n            // true -> legendonly\n            // legendonly -> true\n            var nextVisibility = fullInput.visible === false ? false : visibility;\n\n            insertUpdate(fullInput.index, 'visible', nextVisibility);\n        }\n    }\n\n    if(Registry.traceIs(fullTrace, 'pie-like')) {\n        var thisLabel = legendItem.label;\n        var thisLabelIndex = hiddenSlices.indexOf(thisLabel);\n\n        if(mode === 'toggle') {\n            if(thisLabelIndex === -1) hiddenSlices.push(thisLabel);\n            else hiddenSlices.splice(thisLabelIndex, 1);\n        } else if(mode === 'toggleothers') {\n            hiddenSlices = [];\n            gd.calcdata[0].forEach(function(d) {\n                if(thisLabel !== d.label) {\n                    hiddenSlices.push(d.label);\n                }\n            });\n            if(gd._fullLayout.hiddenlabels && gd._fullLayout.hiddenlabels.length === hiddenSlices.length && thisLabelIndex === -1) {\n                hiddenSlices = [];\n            }\n        }\n\n        Registry.call('_guiRelayout', gd, 'hiddenlabels', hiddenSlices);\n    } else {\n        var hasLegendgroup = legendgroup && legendgroup.length;\n        var traceIndicesInGroup = [];\n        var tracei;\n        if(hasLegendgroup) {\n            for(i = 0; i < fullData.length; i++) {\n                tracei = fullData[i];\n                if(!tracei.visible) continue;\n                if(tracei.legendgroup === legendgroup) {\n                    traceIndicesInGroup.push(i);\n                }\n            }\n        }\n\n        if(mode === 'toggle') {\n            var nextVisibility;\n\n            switch(fullTrace.visible) {\n                case true:\n                    nextVisibility = 'legendonly';\n                    break;\n                case false:\n                    nextVisibility = false;\n                    break;\n                case 'legendonly':\n                    nextVisibility = true;\n                    break;\n            }\n\n            if(hasLegendgroup) {\n                for(i = 0; i < fullData.length; i++) {\n                    if(fullData[i].visible !== false && fullData[i].legendgroup === legendgroup) {\n                        setVisibility(fullData[i], nextVisibility);\n                    }\n                }\n            } else {\n                setVisibility(fullTrace, nextVisibility);\n            }\n        } else if(mode === 'toggleothers') {\n            // Compute the clicked index. expandedIndex does what we want for expanded traces\n            // but also culls hidden traces. That means we have some work to do.\n            var isClicked, isInGroup, notInLegend, otherState;\n            var isIsolated = true;\n            for(i = 0; i < fullData.length; i++) {\n                isClicked = fullData[i] === fullTrace;\n                notInLegend = fullData[i].showlegend !== true;\n                if(isClicked || notInLegend) continue;\n\n                isInGroup = (hasLegendgroup && fullData[i].legendgroup === legendgroup);\n\n                if(!isInGroup && fullData[i].visible === true && !Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n                    isIsolated = false;\n                    break;\n                }\n            }\n\n            for(i = 0; i < fullData.length; i++) {\n                // False is sticky; we don't change it.\n                if(fullData[i].visible === false) continue;\n\n                if(Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n                    continue;\n                }\n\n                switch(fullTrace.visible) {\n                    case 'legendonly':\n                        setVisibility(fullData[i], true);\n                        break;\n                    case true:\n                        otherState = isIsolated ? true : 'legendonly';\n                        isClicked = fullData[i] === fullTrace;\n                        // N.B. consider traces that have a set legendgroup as toggleable\n                        notInLegend = (fullData[i].showlegend !== true && !fullData[i].legendgroup);\n                        isInGroup = isClicked || (hasLegendgroup && fullData[i].legendgroup === legendgroup);\n                        setVisibility(fullData[i], (isInGroup || notInLegend) ? true : otherState);\n                        break;\n                }\n            }\n        }\n\n        for(i = 0; i < carrs.length; i++) {\n            kcont = carrs[i];\n            if(!kcont) continue;\n            var update = kcont.constructUpdate();\n\n            var updateKeys = Object.keys(update);\n            for(j = 0; j < updateKeys.length; j++) {\n                key = updateKeys[j];\n                val = attrUpdate[key] = attrUpdate[key] || [];\n                val[carrIdx[i]] = update[key];\n            }\n        }\n\n        // The length of the value arrays should be equal and any unspecified\n        // values should be explicitly undefined for them to get properly culled\n        // as updates and not accidentally reset to the default value. This fills\n        // out sparse arrays with the required number of undefined values:\n        keys = Object.keys(attrUpdate);\n        for(i = 0; i < keys.length; i++) {\n            key = keys[i];\n            for(j = 0; j < attrIndices.length; j++) {\n                // Use hasOwnPropety to protect against falsey values:\n                if(!attrUpdate[key].hasOwnProperty(j)) {\n                    attrUpdate[key][j] = undefined;\n                }\n            }\n        }\n\n        Registry.call('_guiRestyle', gd, attrUpdate, attrIndices);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}