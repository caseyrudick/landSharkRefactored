{"ast":null,"code":"/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar svgSdf = require('svg-path-sdf');\n\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\n\nvar subTypes = require('../scatter/subtypes');\n\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar helpers = require('./helpers');\n\nvar constants = require('./constants');\n\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  left: 1,\n  end: -1,\n  right: -1,\n  middle: 0,\n  center: 0,\n  bottom: 1,\n  top: -1\n};\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nfunction convertStyle(gd, trace) {\n  var i;\n  var opts = {\n    marker: undefined,\n    markerSel: undefined,\n    markerUnsel: undefined,\n    line: undefined,\n    fill: undefined,\n    errorX: undefined,\n    errorY: undefined,\n    text: undefined,\n    textSel: undefined,\n    textUnsel: undefined\n  };\n  if (trace.visible !== true) return opts;\n\n  if (subTypes.hasText(trace)) {\n    opts.text = convertTextStyle(gd, trace);\n    opts.textSel = convertTextSelection(gd, trace, trace.selected);\n    opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n  }\n\n  if (subTypes.hasMarkers(trace)) {\n    opts.marker = convertMarkerStyle(trace);\n    opts.markerSel = convertMarkerSelection(trace, trace.selected);\n    opts.markerUnsel = convertMarkerSelection(trace, trace.unselected);\n\n    if (!trace.unselected && Lib.isArrayOrTypedArray(trace.marker.opacity)) {\n      var mo = trace.marker.opacity;\n      opts.markerUnsel.opacity = new Array(mo.length);\n\n      for (i = 0; i < mo.length; i++) {\n        opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n      }\n    }\n  }\n\n  if (subTypes.hasLines(trace)) {\n    opts.line = {\n      overlay: true,\n      thickness: trace.line.width,\n      color: trace.line.color,\n      opacity: trace.opacity\n    };\n    var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n\n    for (i = 0; i < dashes.length; ++i) {\n      dashes[i] *= trace.line.width;\n    }\n\n    opts.line.dashes = dashes;\n  }\n\n  if (trace.error_x && trace.error_x.visible) {\n    opts.errorX = convertErrorBarStyle(trace, trace.error_x);\n  }\n\n  if (trace.error_y && trace.error_y.visible) {\n    opts.errorY = convertErrorBarStyle(trace, trace.error_y);\n  }\n\n  if (!!trace.fill && trace.fill !== 'none') {\n    opts.fill = {\n      closed: true,\n      fill: trace.fillcolor,\n      thickness: 0\n    };\n  }\n\n  return opts;\n}\n\nfunction convertTextStyle(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var count = trace._length;\n  var textfontIn = trace.textfont;\n  var textpositionIn = trace.textposition;\n  var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n  var tfc = textfontIn.color;\n  var tfs = textfontIn.size;\n  var tff = textfontIn.family;\n  var optsOut = {};\n  var i;\n  var texttemplate = trace.texttemplate;\n\n  if (texttemplate) {\n    optsOut.text = [];\n    var d3locale = fullLayout._d3locale;\n    var isArray = Array.isArray(texttemplate);\n    var N = isArray ? Math.min(texttemplate.length, count) : count;\n    var txt = isArray ? function (i) {\n      return texttemplate[i];\n    } : function () {\n      return texttemplate;\n    };\n\n    for (i = 0; i < N; i++) {\n      var d = {\n        i: i\n      };\n\n      var labels = trace._module.formatLabels(d, trace, fullLayout);\n\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, i);\n      var meta = trace._meta || {};\n      optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n    }\n  } else {\n    if (Array.isArray(trace.text) && trace.text.length < count) {\n      // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n      optsOut.text = trace.text.slice();\n    } else {\n      optsOut.text = trace.text;\n    }\n  } // pad text array with empty strings\n\n\n  if (Array.isArray(optsOut.text)) {\n    for (i = optsOut.text.length; i < count; i++) {\n      optsOut.text[i] = '';\n    }\n  }\n\n  optsOut.opacity = trace.opacity;\n  optsOut.font = {};\n  optsOut.align = [];\n  optsOut.baseline = [];\n\n  for (i = 0; i < textPos.length; i++) {\n    var tp = textPos[i].split(/\\s+/);\n\n    switch (tp[1]) {\n      case 'left':\n        optsOut.align.push('right');\n        break;\n\n      case 'right':\n        optsOut.align.push('left');\n        break;\n\n      default:\n        optsOut.align.push(tp[1]);\n    }\n\n    switch (tp[0]) {\n      case 'top':\n        optsOut.baseline.push('bottom');\n        break;\n\n      case 'bottom':\n        optsOut.baseline.push('top');\n        break;\n\n      default:\n        optsOut.baseline.push(tp[0]);\n    }\n  }\n\n  if (Array.isArray(tfc)) {\n    optsOut.color = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      optsOut.color[i] = tfc[i];\n    }\n  } else {\n    optsOut.color = tfc;\n  }\n\n  if (Lib.isArrayOrTypedArray(tfs) || Array.isArray(tff)) {\n    // if any textfont param is array - make render a batch\n    optsOut.font = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      var fonti = optsOut.font[i] = {};\n      fonti.size = Lib.isTypedArray(tfs) ? tfs[i] : Array.isArray(tfs) ? isNumeric(tfs[i]) ? tfs[i] : 0 : tfs;\n      fonti.family = Array.isArray(tff) ? tff[i] : tff;\n    }\n  } else {\n    // if both are single values, make render fast single-value\n    optsOut.font = {\n      size: tfs,\n      family: tff\n    };\n  }\n\n  return optsOut;\n}\n\nfunction convertMarkerStyle(trace) {\n  var count = trace._length;\n  var optsIn = trace.marker;\n  var optsOut = {};\n  var i;\n  var multiSymbol = Lib.isArrayOrTypedArray(optsIn.symbol);\n  var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n  var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n  var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n  var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n  var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n  var isOpen;\n  if (!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol); // prepare colors\n\n  if (multiSymbol || multiColor || multiLineColor || multiOpacity) {\n    optsOut.colors = new Array(count);\n    optsOut.borderColors = new Array(count);\n    var colors = formatColor(optsIn, optsIn.opacity, count);\n    var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n    if (!Array.isArray(borderColors[0])) {\n      var borderColor = borderColors;\n      borderColors = Array(count);\n\n      for (i = 0; i < count; i++) {\n        borderColors[i] = borderColor;\n      }\n    }\n\n    if (!Array.isArray(colors[0])) {\n      var color = colors;\n      colors = Array(count);\n\n      for (i = 0; i < count; i++) {\n        colors[i] = color;\n      }\n    }\n\n    optsOut.colors = colors;\n    optsOut.borderColors = borderColors;\n\n    for (i = 0; i < count; i++) {\n      if (multiSymbol) {\n        var symbol = optsIn.symbol[i];\n        isOpen = helpers.isOpenSymbol(symbol);\n      }\n\n      if (isOpen) {\n        borderColors[i] = colors[i].slice();\n        colors[i] = colors[i].slice();\n        colors[i][3] = 0;\n      }\n    }\n\n    optsOut.opacity = trace.opacity;\n  } else {\n    if (isOpen) {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.color[3] = 0;\n      optsOut.borderColor = rgba(optsIn.color, 'uint8');\n    } else {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n    }\n\n    optsOut.opacity = trace.opacity * optsIn.opacity;\n  } // prepare symbols\n\n\n  if (multiSymbol) {\n    optsOut.markers = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      optsOut.markers[i] = getSymbolSdf(optsIn.symbol[i]);\n    }\n  } else {\n    optsOut.marker = getSymbolSdf(optsIn.symbol);\n  } // prepare sizes\n\n\n  var markerSizeFunc = makeBubbleSizeFn(trace);\n  var s;\n\n  if (multiSize || multiLineWidth) {\n    var sizes = optsOut.sizes = new Array(count);\n    var borderSizes = optsOut.borderSizes = new Array(count);\n    var sizeTotal = 0;\n    var sizeAvg;\n\n    if (multiSize) {\n      for (i = 0; i < count; i++) {\n        sizes[i] = markerSizeFunc(optsIn.size[i]);\n        sizeTotal += sizes[i];\n      }\n\n      sizeAvg = sizeTotal / count;\n    } else {\n      s = markerSizeFunc(optsIn.size);\n\n      for (i = 0; i < count; i++) {\n        sizes[i] = s;\n      }\n    } // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n\n\n    if (multiLineWidth) {\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = optsIn.line.width[i] / 2;\n      }\n    } else {\n      s = optsIn.line.width / 2;\n\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = s;\n      }\n    }\n\n    optsOut.sizeAvg = sizeAvg;\n  } else {\n    optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n    optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n  }\n\n  return optsOut;\n}\n\nfunction convertMarkerSelection(trace, target) {\n  var optsIn = trace.marker;\n  var optsOut = {};\n  if (!target) return optsOut;\n\n  if (target.marker && target.marker.symbol) {\n    optsOut = convertMarkerStyle(Lib.extendFlat({}, optsIn, target.marker));\n  } else if (target.marker) {\n    if (target.marker.size) optsOut.size = target.marker.size / 2;\n    if (target.marker.color) optsOut.colors = target.marker.color;\n    if (target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n  }\n\n  return optsOut;\n}\n\nfunction convertTextSelection(gd, trace, target) {\n  var optsOut = {};\n  if (!target) return optsOut;\n\n  if (target.textfont) {\n    var optsIn = {\n      opacity: 1,\n      text: trace.text,\n      texttemplate: trace.texttemplate,\n      textposition: trace.textposition,\n      textfont: Lib.extendFlat({}, trace.textfont)\n    };\n\n    if (target.textfont) {\n      Lib.extendFlat(optsIn.textfont, target.textfont);\n    }\n\n    optsOut = convertTextStyle(gd, optsIn);\n  }\n\n  return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target) {\n  var optsOut = {\n    capSize: target.width * 2,\n    lineWidth: target.thickness,\n    color: target.color\n  };\n\n  if (target.copy_ystyle) {\n    optsOut = trace.error_y;\n  }\n\n  return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(symbol) {\n  if (symbol === 'circle') return null;\n  var symbolPath, symbolSdf;\n  var symbolNumber = Drawing.symbolNumber(symbol);\n  var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n  var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n  var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n  var isDot = helpers.isDotSymbol(symbol); // get symbol sdf from cache or generate it\n\n  if (SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n  if (isDot && !symbolNoDot) {\n    symbolPath = symbolFunc(SYMBOL_SIZE * 1.1) + SYMBOL_SVG_CIRCLE;\n  } else {\n    symbolPath = symbolFunc(SYMBOL_SIZE);\n  }\n\n  symbolSdf = svgSdf(symbolPath, {\n    w: SYMBOL_SDF_SIZE,\n    h: SYMBOL_SDF_SIZE,\n    viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n    stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n  });\n  SYMBOL_SDF[symbol] = symbolSdf;\n  return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n  var len = positions.length;\n  var count = len / 2;\n  var linePositions;\n  var i;\n\n  if (subTypes.hasLines(trace) && count) {\n    if (trace.line.shape === 'hv') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'hvh') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], midPtX, positions[i * 2 + 1], midPtX, positions[i * 2 + 3]);\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vhv') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], positions[i * 2], midPtY, positions[i * 2 + 2], midPtY);\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vh') {\n      linePositions = [];\n\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else {\n      linePositions = positions;\n    }\n  } // If we have data with gaps, we ought to use rect joins\n  // FIXME: get rid of this\n\n\n  var hasNaN = false;\n\n  for (i = 0; i < linePositions.length; i++) {\n    if (isNaN(linePositions[i])) {\n      hasNaN = true;\n      break;\n    }\n  }\n\n  var join = hasNaN || linePositions.length > constants.TOO_MANY_POINTS ? 'rect' : subTypes.hasMarkers(trace) ? 'rect' : 'round'; // fill gaps\n\n  if (hasNaN && trace.connectgaps) {\n    var lastX = linePositions[0];\n    var lastY = linePositions[1];\n\n    for (i = 0; i < linePositions.length; i += 2) {\n      if (isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n        linePositions[i] = lastX;\n        linePositions[i + 1] = lastY;\n      } else {\n        lastX = linePositions[i];\n        lastY = linePositions[i + 1];\n      }\n    }\n  }\n\n  return {\n    join: join,\n    positions: linePositions\n  };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n  var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n  var xa = AxisIDs.getFromId(gd, trace.xaxis);\n  var ya = AxisIDs.getFromId(gd, trace.yaxis);\n  var count = positions.length / 2;\n  var out = {};\n\n  function convertOneAxis(coords, ax) {\n    var axLetter = ax._id.charAt(0);\n\n    var opts = trace['error_' + axLetter];\n\n    if (opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n      var computeError = makeComputeError(opts);\n      var pOffset = {\n        x: 0,\n        y: 1\n      }[axLetter];\n      var eOffset = {\n        x: [0, 1, 2, 3],\n        y: [2, 3, 0, 1]\n      }[axLetter];\n      var errors = new Float64Array(4 * count);\n      var minShoe = Infinity;\n      var maxHat = -Infinity;\n\n      for (var i = 0, j = 0; i < count; i++, j += 4) {\n        var dc = coords[i];\n\n        if (isNumeric(dc)) {\n          var dl = positions[i * 2 + pOffset];\n          var vals = computeError(dc, i);\n          var lv = vals[0];\n          var hv = vals[1];\n\n          if (isNumeric(lv) && isNumeric(hv)) {\n            var shoe = dc - lv;\n            var hat = dc + hv;\n            errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n            errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n            errors[j + eOffset[2]] = 0;\n            errors[j + eOffset[3]] = 0;\n            minShoe = Math.min(minShoe, dc - lv);\n            maxHat = Math.max(maxHat, dc + hv);\n          }\n        }\n      }\n\n      out[axLetter] = {\n        positions: positions,\n        errors: errors,\n        _bnds: [minShoe, maxHat]\n      };\n    }\n  }\n\n  convertOneAxis(x, xa);\n  convertOneAxis(y, ya);\n  return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n  var count = trace._length;\n  var out = {};\n  var i; // corresponds to textPointPosition from component.drawing\n\n  if (subTypes.hasMarkers(trace)) {\n    var fontOpts = textOpts.font;\n    var align = textOpts.align;\n    var baseline = textOpts.baseline;\n    out.offset = new Array(count);\n\n    for (i = 0; i < count; i++) {\n      var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n      var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n      var a = Array.isArray(align) ? align.length > 1 ? align[i] : align[0] : align;\n      var b = Array.isArray(baseline) ? baseline.length > 1 ? baseline[i] : baseline[0] : baseline;\n      var hSign = TEXTOFFSETSIGN[a];\n      var vSign = TEXTOFFSETSIGN[b];\n      var xPad = ms ? ms / 0.8 + 1 : 0;\n      var yPad = -vSign * xPad - vSign * 0.5;\n      out.offset[i] = [hSign * xPad / fs, yPad / fs];\n    }\n  }\n\n  return out;\n}\n\nmodule.exports = {\n  style: convertStyle,\n  markerStyle: convertMarkerStyle,\n  markerSelection: convertMarkerSelection,\n  linePositions: convertLinePositions,\n  errorBarPositions: convertErrorBarPositions,\n  textPosition: convertTextPosition\n};","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/plotly.js/src/traces/scattergl/convert.js"],"names":["isNumeric","require","svgSdf","rgba","Registry","Lib","Drawing","AxisIDs","formatColor","subTypes","makeBubbleSizeFn","helpers","constants","DESELECTDIM","TEXTOFFSETSIGN","start","left","end","right","middle","center","bottom","top","appendArrayPointValue","convertStyle","gd","trace","i","opts","marker","undefined","markerSel","markerUnsel","line","fill","errorX","errorY","text","textSel","textUnsel","visible","hasText","convertTextStyle","convertTextSelection","selected","unselected","hasMarkers","convertMarkerStyle","convertMarkerSelection","isArrayOrTypedArray","opacity","mo","Array","length","hasLines","overlay","thickness","width","color","dashes","DASHES","dash","slice","error_x","convertErrorBarStyle","error_y","closed","fillcolor","fullLayout","_fullLayout","count","_length","textfontIn","textfont","textpositionIn","textposition","textPos","isArray","tfc","tfs","size","tff","family","optsOut","texttemplate","d3locale","_d3locale","N","Math","min","txt","d","labels","_module","formatLabels","pointValues","meta","_meta","push","texttemplateString","font","align","baseline","tp","split","fonti","isTypedArray","optsIn","multiSymbol","symbol","multiColor","multiLineColor","multiOpacity","multiSize","multiLineWidth","isOpen","isOpenSymbol","colors","borderColors","borderColor","markers","getSymbolSdf","markerSizeFunc","s","sizes","borderSizes","sizeTotal","sizeAvg","target","extendFlat","capSize","lineWidth","copy_ystyle","SYMBOL_SDF_SIZE","SYMBOL_SIZE","SYMBOL_STROKE","SYMBOL_SDF","SYMBOL_SVG_CIRCLE","symbolFuncs","symbolPath","symbolSdf","symbolNumber","symbolFunc","symbolNoDot","symbolNoFill","isDot","isDotSymbol","w","h","viewBox","stroke","convertLinePositions","positions","len","linePositions","shape","isNaN","NaN","midPtX","midPtY","hasNaN","join","TOO_MANY_POINTS","connectgaps","lastX","lastY","convertErrorBarPositions","x","y","makeComputeError","getComponentMethod","xa","getFromId","xaxis","ya","yaxis","out","convertOneAxis","coords","ax","axLetter","_id","charAt","type","computeError","pOffset","eOffset","errors","Float64Array","minShoe","Infinity","maxHat","j","dc","dl","vals","lv","hv","shoe","hat","c2l","max","_bnds","convertTextPosition","textOpts","markerOpts","fontOpts","offset","ms","fs","a","b","hSign","vSign","xPad","yPad","module","exports","style","markerStyle","markerSelection","errorBarPositions","textPosition"],"mappings":"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","sourcesContent":["/**\n* Copyright 2012-2020, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n    start: 1, left: 1, end: -1, right: -1, middle: 0, center: 0, bottom: 1, top: -1\n};\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nfunction convertStyle(gd, trace) {\n    var i;\n\n    var opts = {\n        marker: undefined,\n        markerSel: undefined,\n        markerUnsel: undefined,\n        line: undefined,\n        fill: undefined,\n        errorX: undefined,\n        errorY: undefined,\n        text: undefined,\n        textSel: undefined,\n        textUnsel: undefined\n    };\n\n    if(trace.visible !== true) return opts;\n\n    if(subTypes.hasText(trace)) {\n        opts.text = convertTextStyle(gd, trace);\n        opts.textSel = convertTextSelection(gd, trace, trace.selected);\n        opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);\n    }\n\n    if(subTypes.hasMarkers(trace)) {\n        opts.marker = convertMarkerStyle(trace);\n        opts.markerSel = convertMarkerSelection(trace, trace.selected);\n        opts.markerUnsel = convertMarkerSelection(trace, trace.unselected);\n\n        if(!trace.unselected && Lib.isArrayOrTypedArray(trace.marker.opacity)) {\n            var mo = trace.marker.opacity;\n            opts.markerUnsel.opacity = new Array(mo.length);\n            for(i = 0; i < mo.length; i++) {\n                opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n            }\n        }\n    }\n\n    if(subTypes.hasLines(trace)) {\n        opts.line = {\n            overlay: true,\n            thickness: trace.line.width,\n            color: trace.line.color,\n            opacity: trace.opacity\n        };\n\n        var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n        for(i = 0; i < dashes.length; ++i) {\n            dashes[i] *= trace.line.width;\n        }\n        opts.line.dashes = dashes;\n    }\n\n    if(trace.error_x && trace.error_x.visible) {\n        opts.errorX = convertErrorBarStyle(trace, trace.error_x);\n    }\n\n    if(trace.error_y && trace.error_y.visible) {\n        opts.errorY = convertErrorBarStyle(trace, trace.error_y);\n    }\n\n    if(!!trace.fill && trace.fill !== 'none') {\n        opts.fill = {\n            closed: true,\n            fill: trace.fillcolor,\n            thickness: 0\n        };\n    }\n\n    return opts;\n}\n\nfunction convertTextStyle(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var count = trace._length;\n    var textfontIn = trace.textfont;\n    var textpositionIn = trace.textposition;\n    var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n    var tfc = textfontIn.color;\n    var tfs = textfontIn.size;\n    var tff = textfontIn.family;\n    var optsOut = {};\n    var i;\n\n    var texttemplate = trace.texttemplate;\n    if(texttemplate) {\n        optsOut.text = [];\n\n        var d3locale = fullLayout._d3locale;\n        var isArray = Array.isArray(texttemplate);\n        var N = isArray ? Math.min(texttemplate.length, count) : count;\n        var txt = isArray ?\n            function(i) { return texttemplate[i]; } :\n            function() { return texttemplate; };\n\n        for(i = 0; i < N; i++) {\n            var d = {i: i};\n            var labels = trace._module.formatLabels(d, trace, fullLayout);\n            var pointValues = {};\n            appendArrayPointValue(pointValues, trace, i);\n            var meta = trace._meta || {};\n            optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));\n        }\n    } else {\n        if(Array.isArray(trace.text) && trace.text.length < count) {\n            // if text array is shorter, we'll need to append to it, so let's slice to prevent mutating\n            optsOut.text = trace.text.slice();\n        } else {\n            optsOut.text = trace.text;\n        }\n    }\n    // pad text array with empty strings\n    if(Array.isArray(optsOut.text)) {\n        for(i = optsOut.text.length; i < count; i++) {\n            optsOut.text[i] = '';\n        }\n    }\n\n    optsOut.opacity = trace.opacity;\n    optsOut.font = {};\n    optsOut.align = [];\n    optsOut.baseline = [];\n\n    for(i = 0; i < textPos.length; i++) {\n        var tp = textPos[i].split(/\\s+/);\n\n        switch(tp[1]) {\n            case 'left':\n                optsOut.align.push('right');\n                break;\n            case 'right':\n                optsOut.align.push('left');\n                break;\n            default:\n                optsOut.align.push(tp[1]);\n        }\n        switch(tp[0]) {\n            case 'top':\n                optsOut.baseline.push('bottom');\n                break;\n            case 'bottom':\n                optsOut.baseline.push('top');\n                break;\n            default:\n                optsOut.baseline.push(tp[0]);\n        }\n    }\n\n    if(Array.isArray(tfc)) {\n        optsOut.color = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.color[i] = tfc[i];\n        }\n    } else {\n        optsOut.color = tfc;\n    }\n\n    if(Lib.isArrayOrTypedArray(tfs) || Array.isArray(tff)) {\n        // if any textfont param is array - make render a batch\n        optsOut.font = new Array(count);\n        for(i = 0; i < count; i++) {\n            var fonti = optsOut.font[i] = {};\n\n            fonti.size = (\n                Lib.isTypedArray(tfs) ? tfs[i] :\n                Array.isArray(tfs) ? (\n                    isNumeric(tfs[i]) ? tfs[i] : 0\n                ) : tfs\n            );\n\n            fonti.family = Array.isArray(tff) ? tff[i] : tff;\n        }\n    } else {\n        // if both are single values, make render fast single-value\n        optsOut.font = {size: tfs, family: tff};\n    }\n\n    return optsOut;\n}\n\n\nfunction convertMarkerStyle(trace) {\n    var count = trace._length;\n    var optsIn = trace.marker;\n    var optsOut = {};\n    var i;\n\n    var multiSymbol = Lib.isArrayOrTypedArray(optsIn.symbol);\n    var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n    var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n    var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n    var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n    var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n\n    var isOpen;\n    if(!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);\n\n    // prepare colors\n    if(multiSymbol || multiColor || multiLineColor || multiOpacity) {\n        optsOut.colors = new Array(count);\n        optsOut.borderColors = new Array(count);\n\n        var colors = formatColor(optsIn, optsIn.opacity, count);\n        var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n        if(!Array.isArray(borderColors[0])) {\n            var borderColor = borderColors;\n            borderColors = Array(count);\n            for(i = 0; i < count; i++) {\n                borderColors[i] = borderColor;\n            }\n        }\n        if(!Array.isArray(colors[0])) {\n            var color = colors;\n            colors = Array(count);\n            for(i = 0; i < count; i++) {\n                colors[i] = color;\n            }\n        }\n\n        optsOut.colors = colors;\n        optsOut.borderColors = borderColors;\n\n        for(i = 0; i < count; i++) {\n            if(multiSymbol) {\n                var symbol = optsIn.symbol[i];\n                isOpen = helpers.isOpenSymbol(symbol);\n            }\n            if(isOpen) {\n                borderColors[i] = colors[i].slice();\n                colors[i] = colors[i].slice();\n                colors[i][3] = 0;\n            }\n        }\n\n        optsOut.opacity = trace.opacity;\n    } else {\n        if(isOpen) {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.color[3] = 0;\n            optsOut.borderColor = rgba(optsIn.color, 'uint8');\n        } else {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n        }\n\n        optsOut.opacity = trace.opacity * optsIn.opacity;\n    }\n\n    // prepare symbols\n    if(multiSymbol) {\n        optsOut.markers = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.markers[i] = getSymbolSdf(optsIn.symbol[i]);\n        }\n    } else {\n        optsOut.marker = getSymbolSdf(optsIn.symbol);\n    }\n\n    // prepare sizes\n    var markerSizeFunc = makeBubbleSizeFn(trace);\n    var s;\n\n    if(multiSize || multiLineWidth) {\n        var sizes = optsOut.sizes = new Array(count);\n        var borderSizes = optsOut.borderSizes = new Array(count);\n        var sizeTotal = 0;\n        var sizeAvg;\n\n        if(multiSize) {\n            for(i = 0; i < count; i++) {\n                sizes[i] = markerSizeFunc(optsIn.size[i]);\n                sizeTotal += sizes[i];\n            }\n            sizeAvg = sizeTotal / count;\n        } else {\n            s = markerSizeFunc(optsIn.size);\n            for(i = 0; i < count; i++) {\n                sizes[i] = s;\n            }\n        }\n\n        // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n        if(multiLineWidth) {\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = optsIn.line.width[i] / 2;\n            }\n        } else {\n            s = optsIn.line.width / 2;\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = s;\n            }\n        }\n\n        optsOut.sizeAvg = sizeAvg;\n    } else {\n        optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n        optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n    }\n\n    return optsOut;\n}\n\nfunction convertMarkerSelection(trace, target) {\n    var optsIn = trace.marker;\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.marker && target.marker.symbol) {\n        optsOut = convertMarkerStyle(Lib.extendFlat({}, optsIn, target.marker));\n    } else if(target.marker) {\n        if(target.marker.size) optsOut.size = target.marker.size / 2;\n        if(target.marker.color) optsOut.colors = target.marker.color;\n        if(target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n    }\n\n    return optsOut;\n}\n\nfunction convertTextSelection(gd, trace, target) {\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.textfont) {\n        var optsIn = {\n            opacity: 1,\n            text: trace.text,\n            texttemplate: trace.texttemplate,\n            textposition: trace.textposition,\n            textfont: Lib.extendFlat({}, trace.textfont)\n        };\n        if(target.textfont) {\n            Lib.extendFlat(optsIn.textfont, target.textfont);\n        }\n        optsOut = convertTextStyle(gd, optsIn);\n    }\n\n    return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target) {\n    var optsOut = {\n        capSize: target.width * 2,\n        lineWidth: target.thickness,\n        color: target.color\n    };\n\n    if(target.copy_ystyle) {\n        optsOut = trace.error_y;\n    }\n\n    return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(symbol) {\n    if(symbol === 'circle') return null;\n\n    var symbolPath, symbolSdf;\n    var symbolNumber = Drawing.symbolNumber(symbol);\n    var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n    var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n    var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n\n    var isDot = helpers.isDotSymbol(symbol);\n\n    // get symbol sdf from cache or generate it\n    if(SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n    if(isDot && !symbolNoDot) {\n        symbolPath = symbolFunc(SYMBOL_SIZE * 1.1) + SYMBOL_SVG_CIRCLE;\n    } else {\n        symbolPath = symbolFunc(SYMBOL_SIZE);\n    }\n\n    symbolSdf = svgSdf(symbolPath, {\n        w: SYMBOL_SDF_SIZE,\n        h: SYMBOL_SDF_SIZE,\n        viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n        stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n    });\n    SYMBOL_SDF[symbol] = symbolSdf;\n\n    return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n    var len = positions.length;\n    var count = len / 2;\n    var linePositions;\n    var i;\n\n    if(subTypes.hasLines(trace) && count) {\n        if(trace.line.shape === 'hv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'hvh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 3]\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vhv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                } else {\n                    var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        positions[i * 2],\n                        midPtY,\n                        positions[i * 2 + 2],\n                        midPtY\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else {\n            linePositions = positions;\n        }\n    }\n\n    // If we have data with gaps, we ought to use rect joins\n    // FIXME: get rid of this\n    var hasNaN = false;\n    for(i = 0; i < linePositions.length; i++) {\n        if(isNaN(linePositions[i])) {\n            hasNaN = true;\n            break;\n        }\n    }\n\n    var join = (hasNaN || linePositions.length > constants.TOO_MANY_POINTS) ? 'rect' :\n        subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n    // fill gaps\n    if(hasNaN && trace.connectgaps) {\n        var lastX = linePositions[0];\n        var lastY = linePositions[1];\n\n        for(i = 0; i < linePositions.length; i += 2) {\n            if(isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n                linePositions[i] = lastX;\n                linePositions[i + 1] = lastY;\n            } else {\n                lastX = linePositions[i];\n                lastY = linePositions[i + 1];\n            }\n        }\n    }\n\n    return {\n        join: join,\n        positions: linePositions\n    };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n    var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n    var xa = AxisIDs.getFromId(gd, trace.xaxis);\n    var ya = AxisIDs.getFromId(gd, trace.yaxis);\n    var count = positions.length / 2;\n    var out = {};\n\n    function convertOneAxis(coords, ax) {\n        var axLetter = ax._id.charAt(0);\n        var opts = trace['error_' + axLetter];\n\n        if(opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n            var computeError = makeComputeError(opts);\n            var pOffset = {x: 0, y: 1}[axLetter];\n            var eOffset = {x: [0, 1, 2, 3], y: [2, 3, 0, 1]}[axLetter];\n            var errors = new Float64Array(4 * count);\n            var minShoe = Infinity;\n            var maxHat = -Infinity;\n\n            for(var i = 0, j = 0; i < count; i++, j += 4) {\n                var dc = coords[i];\n\n                if(isNumeric(dc)) {\n                    var dl = positions[i * 2 + pOffset];\n                    var vals = computeError(dc, i);\n                    var lv = vals[0];\n                    var hv = vals[1];\n\n                    if(isNumeric(lv) && isNumeric(hv)) {\n                        var shoe = dc - lv;\n                        var hat = dc + hv;\n\n                        errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n                        errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n                        errors[j + eOffset[2]] = 0;\n                        errors[j + eOffset[3]] = 0;\n\n                        minShoe = Math.min(minShoe, dc - lv);\n                        maxHat = Math.max(maxHat, dc + hv);\n                    }\n                }\n            }\n\n            out[axLetter] = {\n                positions: positions,\n                errors: errors,\n                _bnds: [minShoe, maxHat]\n            };\n        }\n    }\n\n    convertOneAxis(x, xa);\n    convertOneAxis(y, ya);\n    return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n    var count = trace._length;\n    var out = {};\n    var i;\n\n    // corresponds to textPointPosition from component.drawing\n    if(subTypes.hasMarkers(trace)) {\n        var fontOpts = textOpts.font;\n        var align = textOpts.align;\n        var baseline = textOpts.baseline;\n        out.offset = new Array(count);\n\n        for(i = 0; i < count; i++) {\n            var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n            var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n\n            var a = Array.isArray(align) ?\n                (align.length > 1 ? align[i] : align[0]) :\n                align;\n            var b = Array.isArray(baseline) ?\n                (baseline.length > 1 ? baseline[i] : baseline[0]) :\n                baseline;\n\n            var hSign = TEXTOFFSETSIGN[a];\n            var vSign = TEXTOFFSETSIGN[b];\n            var xPad = ms ? ms / 0.8 + 1 : 0;\n            var yPad = -vSign * xPad - vSign * 0.5;\n            out.offset[i] = [hSign * xPad / fs, yPad / fs];\n        }\n    }\n\n    return out;\n}\n\nmodule.exports = {\n    style: convertStyle,\n\n    markerStyle: convertMarkerStyle,\n    markerSelection: convertMarkerSelection,\n\n    linePositions: convertLinePositions,\n    errorBarPositions: convertErrorBarPositions,\n    textPosition: convertTextPosition\n};\n"]},"metadata":{},"sourceType":"script"}