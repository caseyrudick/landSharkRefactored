{"ast":null,"code":"import EW from './EW';\nimport NS from './NS';\nexport default ((measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior = 1, inclinationPrior = 2, azimuthPrior = 3, calculatedNorthingPrior = 0.02, calculatedEastingPrior = 0, index, vsDirection = 0) => {\n  const converter = Math.PI / 180;\n  const converter2 = 0.00000001;\n  const calculatedEastingCurrent = EW(measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior, inclinationPrior, azimuthPrior, calculatedEastingPrior);\n  const calculatedNorthingCurrent = NS(measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior, inclinationPrior, azimuthPrior, calculatedNorthingPrior);\n  const closure = Math.atan2(calculatedEastingCurrent, calculatedNorthingCurrent + converter2) / converter;\n\n  const determineClosure = () => {\n    if (closure < 0) {\n      return Math.cos((360 + closure - vsDirection) * converter);\n    } else {\n      return Math.cos((closure - vsDirection) * converter);\n    }\n  };\n\n  const HD = Math.sqrt(Math.pow(calculatedNorthingCurrent, 2) + Math.pow(calculatedEastingCurrent, 2));\n  const calculatedSect = HD * determineClosure();\n  return parseFloat(calculatedSect.toFixed(2));\n});","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/src/HelperFunctions/Calculations/SECT.js"],"names":["EW","NS","measuredDepthCurrent","inclinationCurrent","azimuthCurrent","measuredDepthPrior","inclinationPrior","azimuthPrior","calculatedNorthingPrior","calculatedEastingPrior","index","vsDirection","converter","Math","PI","converter2","calculatedEastingCurrent","calculatedNorthingCurrent","closure","atan2","determineClosure","cos","HD","sqrt","pow","calculatedSect","parseFloat","toFixed"],"mappings":"AAAA,OAAOA,EAAP,MAAe,MAAf;AACA,OAAOC,EAAP,MAAe,MAAf;AAEA,gBAAe,CAACC,oBAAD,EAAuBC,kBAAvB,EAA2CC,cAA3C,EAA2DC,kBAAkB,GAAG,CAAhF,EAAmFC,gBAAgB,GAAG,CAAtG,EAAyGC,YAAY,GAAG,CAAxH,EAA2HC,uBAAuB,GAAG,IAArJ,EAA2JC,sBAAsB,GAAG,CAApL,EAAuLC,KAAvL,EAA8LC,WAAW,GAAG,CAA5M,KAAkN;AAC/N,QAAMC,SAAS,GAAIC,IAAI,CAACC,EAAN,GAAU,GAA5B;AACA,QAAMC,UAAU,GAAG,UAAnB;AAEA,QAAMC,wBAAwB,GAAGhB,EAAE,CAACE,oBAAD,EAAuBC,kBAAvB,EAA2CC,cAA3C,EAA2DC,kBAA3D,EAA+EC,gBAA/E,EAAiGC,YAAjG,EAA+GE,sBAA/G,CAAnC;AAEA,QAAMQ,yBAAyB,GAAGhB,EAAE,CAACC,oBAAD,EAAuBC,kBAAvB,EAA2CC,cAA3C,EAA2DC,kBAA3D,EAA+EC,gBAA/E,EAAiGC,YAAjG,EAA+GC,uBAA/G,CAApC;AAEA,QAAMU,OAAO,GAAGL,IAAI,CAACM,KAAL,CAAWH,wBAAX,EAAqCC,yBAAyB,GAAGF,UAAjE,IAA+EH,SAA/F;;AAEA,QAAMQ,gBAAgB,GAAG,MAAM;AAC7B,QAAIF,OAAO,GAAG,CAAd,EAAiB;AACf,aAAOL,IAAI,CAACQ,GAAL,CAAS,CAAE,MAAMH,OAAP,GAAkBP,WAAnB,IAAkCC,SAA3C,CAAP;AACD,KAFD,MAEO;AACL,aAAOC,IAAI,CAACQ,GAAL,CAAS,CAACH,OAAO,GAAGP,WAAX,IAA0BC,SAAnC,CAAP;AACD;AACF,GAND;;AAQA,QAAMU,EAAE,GAAGT,IAAI,CAACU,IAAL,CAAUV,IAAI,CAACW,GAAL,CAASP,yBAAT,EAAoC,CAApC,IAAyCJ,IAAI,CAACW,GAAL,CAASR,wBAAT,EAAmC,CAAnC,CAAnD,CAAX;AAEA,QAAMS,cAAc,GAAGH,EAAE,GAAGF,gBAAgB,EAA5C;AAGA,SACEM,UAAU,CAACD,cAAc,CAACE,OAAf,CAAuB,CAAvB,CAAD,CADZ;AAGD,CA1BD","sourcesContent":["import EW from './EW';\nimport NS from './NS';\n\nexport default (measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior = 1, inclinationPrior = 2, azimuthPrior = 3, calculatedNorthingPrior = 0.02, calculatedEastingPrior = 0, index, vsDirection = 0) => {\n  const converter = (Math.PI)/180;\n  const converter2 = 0.00000001;\n\n  const calculatedEastingCurrent = EW(measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior, inclinationPrior, azimuthPrior, calculatedEastingPrior)\n\n  const calculatedNorthingCurrent = NS(measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior, inclinationPrior, azimuthPrior, calculatedNorthingPrior)\n\n  const closure = Math.atan2(calculatedEastingCurrent, calculatedNorthingCurrent + converter2) / converter\n\n  const determineClosure = () => {\n    if (closure < 0) {\n      return Math.cos(((360 + closure) - vsDirection) * converter)\n    } else {\n      return Math.cos((closure - vsDirection) * converter)\n    }\n  }\n\n  const HD = Math.sqrt(Math.pow(calculatedNorthingCurrent, 2) + Math.pow(calculatedEastingCurrent, 2))\n\n  const calculatedSect = HD * determineClosure()\n\n\n  return (\n    parseFloat(calculatedSect.toFixed(2))\n  )\n};\n"]},"metadata":{},"sourceType":"module"}