{"ast":null,"code":"\"use strict\";\n\nvar pool = require(\"typedarray-pool\");\n\nmodule.exports = createSurfaceExtractor; //Helper macros\n\nfunction array(i) {\n  return \"a\" + i;\n}\n\nfunction data(i) {\n  return \"d\" + i;\n}\n\nfunction cube(i, bitmask) {\n  return \"c\" + i + \"_\" + bitmask;\n}\n\nfunction shape(i) {\n  return \"s\" + i;\n}\n\nfunction stride(i, j) {\n  return \"t\" + i + \"_\" + j;\n}\n\nfunction offset(i) {\n  return \"o\" + i;\n}\n\nfunction scalar(i) {\n  return \"x\" + i;\n}\n\nfunction pointer(i) {\n  return \"p\" + i;\n}\n\nfunction delta(i, bitmask) {\n  return \"d\" + i + \"_\" + bitmask;\n}\n\nfunction index(i) {\n  return \"i\" + i;\n}\n\nfunction step(i, j) {\n  return \"u\" + i + \"_\" + j;\n}\n\nfunction pcube(bitmask) {\n  return \"b\" + bitmask;\n}\n\nfunction qcube(bitmask) {\n  return \"y\" + bitmask;\n}\n\nfunction pdelta(bitmask) {\n  return \"e\" + bitmask;\n}\n\nfunction vert(i) {\n  return \"v\" + i;\n}\n\nvar VERTEX_IDS = \"V\";\nvar PHASES = \"P\";\nvar VERTEX_COUNT = \"N\";\nvar POOL_SIZE = \"Q\";\nvar POINTER = \"X\";\nvar TEMPORARY = \"T\";\n\nfunction permBitmask(dimension, mask, order) {\n  var r = 0;\n\n  for (var i = 0; i < dimension; ++i) {\n    if (mask & 1 << i) {\n      r |= 1 << order[i];\n    }\n  }\n\n  return r;\n} //Generates the surface procedure\n\n\nfunction compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {\n  var arrayArgs = typesig.length;\n  var dimension = order.length;\n\n  if (dimension < 2) {\n    throw new Error(\"ndarray-extract-contour: Dimension must be at least 2\");\n  }\n\n  var funcName = \"extractContour\" + order.join(\"_\");\n  var code = [];\n  var vars = [];\n  var args = []; //Assemble arguments\n\n  for (var i = 0; i < arrayArgs; ++i) {\n    args.push(array(i));\n  }\n\n  for (var i = 0; i < scalarArgs; ++i) {\n    args.push(scalar(i));\n  } //Shape\n\n\n  for (var i = 0; i < dimension; ++i) {\n    vars.push(shape(i) + \"=\" + array(0) + \".shape[\" + i + \"]|0\");\n  } //Data, stride, offset pointers\n\n\n  for (var i = 0; i < arrayArgs; ++i) {\n    vars.push(data(i) + \"=\" + array(i) + \".data\", offset(i) + \"=\" + array(i) + \".offset|0\");\n\n    for (var j = 0; j < dimension; ++j) {\n      vars.push(stride(i, j) + \"=\" + array(i) + \".stride[\" + j + \"]|0\");\n    }\n  } //Pointer, delta and cube variables\n\n\n  for (var i = 0; i < arrayArgs; ++i) {\n    vars.push(pointer(i) + \"=\" + offset(i));\n    vars.push(cube(i, 0));\n\n    for (var j = 1; j < 1 << dimension; ++j) {\n      var ptrStr = [];\n\n      for (var k = 0; k < dimension; ++k) {\n        if (j & 1 << k) {\n          ptrStr.push(\"-\" + stride(i, k));\n        }\n      }\n\n      vars.push(delta(i, j) + \"=(\" + ptrStr.join(\"\") + \")|0\");\n      vars.push(cube(i, j) + \"=0\");\n    }\n  } //Create step variables\n\n\n  for (var i = 0; i < arrayArgs; ++i) {\n    for (var j = 0; j < dimension; ++j) {\n      var stepVal = [stride(i, order[j])];\n\n      if (j > 0) {\n        stepVal.push(stride(i, order[j - 1]) + \"*\" + shape(order[j - 1]));\n      }\n\n      vars.push(step(i, order[j]) + \"=(\" + stepVal.join(\"-\") + \")|0\");\n    }\n  } //Create index variables\n\n\n  for (var i = 0; i < dimension; ++i) {\n    vars.push(index(i) + \"=0\");\n  } //Vertex count\n\n\n  vars.push(VERTEX_COUNT + \"=0\"); //Compute pool size, initialize pool step\n\n  var sizeVariable = [\"2\"];\n\n  for (var i = dimension - 2; i >= 0; --i) {\n    sizeVariable.push(shape(order[i]));\n  } //Previous phases and vertex_ids\n\n\n  vars.push(POOL_SIZE + \"=(\" + sizeVariable.join(\"*\") + \")|0\", PHASES + \"=mallocUint32(\" + POOL_SIZE + \")\", VERTEX_IDS + \"=mallocUint32(\" + POOL_SIZE + \")\", POINTER + \"=0\"); //Create cube variables for phases\n\n  vars.push(pcube(0) + \"=0\");\n\n  for (var j = 1; j < 1 << dimension; ++j) {\n    var cubeDelta = [];\n    var cubeStep = [];\n\n    for (var k = 0; k < dimension; ++k) {\n      if (j & 1 << k) {\n        if (cubeStep.length === 0) {\n          cubeDelta.push(\"1\");\n        } else {\n          cubeDelta.unshift(cubeStep.join(\"*\"));\n        }\n      }\n\n      cubeStep.push(shape(order[k]));\n    }\n\n    var signFlag = \"\";\n\n    if (cubeDelta[0].indexOf(shape(order[dimension - 2])) < 0) {\n      signFlag = \"-\";\n    }\n\n    var jperm = permBitmask(dimension, j, order);\n    vars.push(pdelta(jperm) + \"=(-\" + cubeDelta.join(\"-\") + \")|0\", qcube(jperm) + \"=(\" + signFlag + cubeDelta.join(\"-\") + \")|0\", pcube(jperm) + \"=0\");\n  }\n\n  vars.push(vert(0) + \"=0\", TEMPORARY + \"=0\");\n\n  function forLoopBegin(i, start) {\n    code.push(\"for(\", index(order[i]), \"=\", start, \";\", index(order[i]), \"<\", shape(order[i]), \";\", \"++\", index(order[i]), \"){\");\n  }\n\n  function forLoopEnd(i) {\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[i]), \";\");\n    }\n\n    code.push(\"}\");\n  }\n\n  function fillEmptySlice(k) {\n    for (var i = k - 1; i >= 0; --i) {\n      forLoopBegin(i, 0);\n    }\n\n    var phaseFuncArgs = [];\n\n    for (var i = 0; i < arrayArgs; ++i) {\n      if (typesig[i]) {\n        phaseFuncArgs.push(data(i) + \".get(\" + pointer(i) + \")\");\n      } else {\n        phaseFuncArgs.push(data(i) + \"[\" + pointer(i) + \"]\");\n      }\n    }\n\n    for (var i = 0; i < scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i));\n    }\n\n    code.push(PHASES, \"[\", POINTER, \"++]=phase(\", phaseFuncArgs.join(), \");\");\n\n    for (var i = 0; i < k; ++i) {\n      forLoopEnd(i);\n    }\n\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[k]), \";\");\n    }\n  }\n\n  function processGridCell(mask) {\n    //Read in local data\n    for (var i = 0; i < arrayArgs; ++i) {\n      if (typesig[i]) {\n        code.push(cube(i, 0), \"=\", data(i), \".get(\", pointer(i), \");\");\n      } else {\n        code.push(cube(i, 0), \"=\", data(i), \"[\", pointer(i), \"];\");\n      }\n    } //Read in phase\n\n\n    var phaseFuncArgs = [];\n\n    for (var i = 0; i < arrayArgs; ++i) {\n      phaseFuncArgs.push(cube(i, 0));\n    }\n\n    for (var i = 0; i < scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i));\n    }\n\n    code.push(pcube(0), \"=\", PHASES, \"[\", POINTER, \"]=phase(\", phaseFuncArgs.join(), \");\"); //Read in other cube data\n\n    for (var j = 1; j < 1 << dimension; ++j) {\n      code.push(pcube(j), \"=\", PHASES, \"[\", POINTER, \"+\", pdelta(j), \"];\");\n    } //Check for boundary crossing\n\n\n    var vertexPredicate = [];\n\n    for (var j = 1; j < 1 << dimension; ++j) {\n      vertexPredicate.push(\"(\" + pcube(0) + \"!==\" + pcube(j) + \")\");\n    }\n\n    code.push(\"if(\", vertexPredicate.join(\"||\"), \"){\"); //Read in boundary data\n\n    var vertexArgs = [];\n\n    for (var i = 0; i < dimension; ++i) {\n      vertexArgs.push(index(i));\n    }\n\n    for (var i = 0; i < arrayArgs; ++i) {\n      vertexArgs.push(cube(i, 0));\n\n      for (var j = 1; j < 1 << dimension; ++j) {\n        if (typesig[i]) {\n          code.push(cube(i, j), \"=\", data(i), \".get(\", pointer(i), \"+\", delta(i, j), \");\");\n        } else {\n          code.push(cube(i, j), \"=\", data(i), \"[\", pointer(i), \"+\", delta(i, j), \"];\");\n        }\n\n        vertexArgs.push(cube(i, j));\n      }\n    }\n\n    for (var i = 0; i < 1 << dimension; ++i) {\n      vertexArgs.push(pcube(i));\n    }\n\n    for (var i = 0; i < scalarArgs; ++i) {\n      vertexArgs.push(scalar(i));\n    } //Generate vertex\n\n\n    code.push(\"vertex(\", vertexArgs.join(), \");\", vert(0), \"=\", VERTEX_IDS, \"[\", POINTER, \"]=\", VERTEX_COUNT, \"++;\"); //Check for face crossings\n\n    var base = (1 << dimension) - 1;\n    var corner = pcube(base);\n\n    for (var j = 0; j < dimension; ++j) {\n      if ((mask & ~(1 << j)) === 0) {\n        //Check face\n        var subset = base ^ 1 << j;\n        var edge = pcube(subset);\n        var faceArgs = [];\n\n        for (var k = subset; k > 0; k = k - 1 & subset) {\n          faceArgs.push(VERTEX_IDS + \"[\" + POINTER + \"+\" + pdelta(k) + \"]\");\n        }\n\n        faceArgs.push(vert(0));\n\n        for (var k = 0; k < arrayArgs; ++k) {\n          if (j & 1) {\n            faceArgs.push(cube(k, base), cube(k, subset));\n          } else {\n            faceArgs.push(cube(k, subset), cube(k, base));\n          }\n        }\n\n        if (j & 1) {\n          faceArgs.push(corner, edge);\n        } else {\n          faceArgs.push(edge, corner);\n        }\n\n        for (var k = 0; k < scalarArgs; ++k) {\n          faceArgs.push(scalar(k));\n        }\n\n        code.push(\"if(\", corner, \"!==\", edge, \"){\", \"face(\", faceArgs.join(), \")}\");\n      }\n    } //Increment pointer, close off if statement\n\n\n    code.push(\"}\", POINTER, \"+=1;\");\n  }\n\n  function flip() {\n    for (var j = 1; j < 1 << dimension; ++j) {\n      code.push(TEMPORARY, \"=\", pdelta(j), \";\", pdelta(j), \"=\", qcube(j), \";\", qcube(j), \"=\", TEMPORARY, \";\");\n    }\n  }\n\n  function createLoop(i, mask) {\n    if (i < 0) {\n      processGridCell(mask);\n      return;\n    }\n\n    fillEmptySlice(i);\n    code.push(\"if(\", shape(order[i]), \">0){\", index(order[i]), \"=1;\");\n    createLoop(i - 1, mask | 1 << order[i]);\n\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[i]), \";\");\n    }\n\n    if (i === dimension - 1) {\n      code.push(POINTER, \"=0;\");\n      flip();\n    }\n\n    forLoopBegin(i, 2);\n    createLoop(i - 1, mask);\n\n    if (i === dimension - 1) {\n      code.push(\"if(\", index(order[dimension - 1]), \"&1){\", POINTER, \"=0;}\");\n      flip();\n    }\n\n    forLoopEnd(i);\n    code.push(\"}\");\n  }\n\n  createLoop(dimension - 1, 0); //Release scratch memory\n\n  code.push(\"freeUint32(\", VERTEX_IDS, \");freeUint32(\", PHASES, \");\"); //Compile and link procedure\n\n  var procedureCode = [\"'use strict';\", \"function \", funcName, \"(\", args.join(), \"){\", \"var \", vars.join(), \";\", code.join(\"\"), \"}\", \"return \", funcName].join(\"\");\n  var proc = new Function(\"vertex\", \"face\", \"phase\", \"mallocUint32\", \"freeUint32\", procedureCode);\n  return proc(vertexFunc, faceFunc, phaseFunc, pool.mallocUint32, pool.freeUint32);\n}\n\nfunction createSurfaceExtractor(args) {\n  function error(msg) {\n    throw new Error(\"ndarray-extract-contour: \" + msg);\n  }\n\n  if (typeof args !== \"object\") {\n    error(\"Must specify arguments\");\n  }\n\n  var order = args.order;\n\n  if (!Array.isArray(order)) {\n    error(\"Must specify order\");\n  }\n\n  var arrays = args.arrayArguments || 1;\n\n  if (arrays < 1) {\n    error(\"Must have at least one array argument\");\n  }\n\n  var scalars = args.scalarArguments || 0;\n\n  if (scalars < 0) {\n    error(\"Scalar arg count must be > 0\");\n  }\n\n  if (typeof args.vertex !== \"function\") {\n    error(\"Must specify vertex creation function\");\n  }\n\n  if (typeof args.cell !== \"function\") {\n    error(\"Must specify cell creation function\");\n  }\n\n  if (typeof args.phase !== \"function\") {\n    error(\"Must specify phase function\");\n  }\n\n  var getters = args.getters || [];\n  var typesig = new Array(arrays);\n\n  for (var i = 0; i < arrays; ++i) {\n    if (getters.indexOf(i) >= 0) {\n      typesig[i] = true;\n    } else {\n      typesig[i] = false;\n    }\n  }\n\n  return compileSurfaceProcedure(args.vertex, args.cell, args.phase, scalars, order, typesig);\n}","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/ndarray-extract-contour/contour.js"],"names":["pool","require","module","exports","createSurfaceExtractor","array","i","data","cube","bitmask","shape","stride","j","offset","scalar","pointer","delta","index","step","pcube","qcube","pdelta","vert","VERTEX_IDS","PHASES","VERTEX_COUNT","POOL_SIZE","POINTER","TEMPORARY","permBitmask","dimension","mask","order","r","compileSurfaceProcedure","vertexFunc","faceFunc","phaseFunc","scalarArgs","typesig","arrayArgs","length","Error","funcName","join","code","vars","args","push","ptrStr","k","stepVal","sizeVariable","cubeDelta","cubeStep","unshift","signFlag","indexOf","jperm","forLoopBegin","start","forLoopEnd","fillEmptySlice","phaseFuncArgs","processGridCell","vertexPredicate","vertexArgs","base","corner","subset","edge","faceArgs","flip","createLoop","procedureCode","proc","Function","mallocUint32","freeUint32","error","msg","Array","isArray","arrays","arrayArguments","scalars","scalarArguments","vertex","cell","phase","getters"],"mappings":"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","sourcesContent":["\"use strict\"\n\nvar pool = require(\"typedarray-pool\")\n\nmodule.exports = createSurfaceExtractor\n\n//Helper macros\nfunction array(i) {\n  return \"a\" + i\n}\nfunction data(i) {\n  return \"d\" + i\n}\nfunction cube(i,bitmask) {\n  return \"c\" + i + \"_\" + bitmask\n}\nfunction shape(i) {\n  return \"s\" + i\n}\nfunction stride(i,j) {\n  return \"t\" + i + \"_\" + j\n}\nfunction offset(i) {\n  return \"o\" + i\n}\nfunction scalar(i) {\n  return \"x\" + i\n}\nfunction pointer(i) {\n  return \"p\" + i\n}\nfunction delta(i,bitmask) {\n  return \"d\" + i + \"_\" + bitmask\n}\nfunction index(i) {\n  return \"i\" + i\n}\nfunction step(i,j) {\n  return \"u\" + i + \"_\" + j\n}\nfunction pcube(bitmask) {\n  return \"b\" + bitmask\n}\nfunction qcube(bitmask) {\n  return \"y\" + bitmask\n}\nfunction pdelta(bitmask) {\n  return \"e\" + bitmask\n}\nfunction vert(i) {\n  return \"v\" + i\n}\nvar VERTEX_IDS = \"V\"\nvar PHASES = \"P\"\nvar VERTEX_COUNT = \"N\"\nvar POOL_SIZE = \"Q\"\nvar POINTER = \"X\"\nvar TEMPORARY = \"T\"\n\nfunction permBitmask(dimension, mask, order) {\n  var r = 0\n  for(var i=0; i<dimension; ++i) {\n    if(mask & (1<<i)) {\n      r |= (1<<order[i])\n    }\n  }\n  return r\n}\n\n//Generates the surface procedure\nfunction compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {\n  var arrayArgs = typesig.length\n  var dimension = order.length\n\n  if(dimension < 2) {\n    throw new Error(\"ndarray-extract-contour: Dimension must be at least 2\")\n  }\n\n  var funcName = \"extractContour\" + order.join(\"_\")\n  var code = []\n  var vars = []\n  var args = []\n\n  //Assemble arguments\n  for(var i=0; i<arrayArgs; ++i) {\n    args.push(array(i))  \n  }\n  for(var i=0; i<scalarArgs; ++i) {\n    args.push(scalar(i))\n  }\n\n  //Shape\n  for(var i=0; i<dimension; ++i) {\n    vars.push(shape(i) + \"=\" + array(0) + \".shape[\" + i + \"]|0\")\n  }\n  //Data, stride, offset pointers\n  for(var i=0; i<arrayArgs; ++i) {\n    vars.push(data(i) + \"=\" + array(i) + \".data\",\n              offset(i) + \"=\" + array(i) + \".offset|0\")\n    for(var j=0; j<dimension; ++j) {\n      vars.push(stride(i,j) + \"=\" + array(i) + \".stride[\" + j + \"]|0\")\n    }\n  }\n  //Pointer, delta and cube variables\n  for(var i=0; i<arrayArgs; ++i) {\n    vars.push(pointer(i) + \"=\" + offset(i))\n    vars.push(cube(i,0))\n    for(var j=1; j<(1<<dimension); ++j) {\n      var ptrStr = []\n      for(var k=0; k<dimension; ++k) {\n        if(j & (1<<k)) {\n          ptrStr.push(\"-\" + stride(i,k))\n        }\n      }\n      vars.push(delta(i,j) + \"=(\" + ptrStr.join(\"\") + \")|0\")\n      vars.push(cube(i,j) + \"=0\")\n    }\n  }\n  //Create step variables\n  for(var i=0; i<arrayArgs; ++i) {\n    for(var j=0; j<dimension; ++j) {\n      var stepVal = [ stride(i,order[j]) ]\n      if(j > 0) {\n        stepVal.push(stride(i, order[j-1]) + \"*\" + shape(order[j-1]) )\n      }\n      vars.push(step(i,order[j]) + \"=(\" + stepVal.join(\"-\") + \")|0\")\n    }\n  }\n  //Create index variables\n  for(var i=0; i<dimension; ++i) {\n    vars.push(index(i) + \"=0\")\n  }\n  //Vertex count\n  vars.push(VERTEX_COUNT + \"=0\")\n  //Compute pool size, initialize pool step\n  var sizeVariable = [\"2\"]\n  for(var i=dimension-2; i>=0; --i) {\n    sizeVariable.push(shape(order[i]))\n  }\n  //Previous phases and vertex_ids\n  vars.push(POOL_SIZE + \"=(\" + sizeVariable.join(\"*\") + \")|0\",\n            PHASES + \"=mallocUint32(\" + POOL_SIZE + \")\",\n            VERTEX_IDS + \"=mallocUint32(\" + POOL_SIZE + \")\",\n            POINTER + \"=0\")\n  //Create cube variables for phases\n  vars.push(pcube(0) + \"=0\")\n  for(var j=1; j<(1<<dimension); ++j) {\n    var cubeDelta = []\n    var cubeStep = [ ]\n    for(var k=0; k<dimension; ++k) {\n      if(j & (1<<k)) {\n        if(cubeStep.length === 0) {\n          cubeDelta.push(\"1\")\n        } else {\n          cubeDelta.unshift(cubeStep.join(\"*\"))\n        }\n      }\n      cubeStep.push(shape(order[k]))\n    }\n    var signFlag = \"\"\n    if(cubeDelta[0].indexOf(shape(order[dimension-2])) < 0) {\n      signFlag = \"-\"\n    }\n    var jperm = permBitmask(dimension, j, order)\n    vars.push(pdelta(jperm) + \"=(-\" + cubeDelta.join(\"-\") + \")|0\",\n              qcube(jperm) + \"=(\" + signFlag + cubeDelta.join(\"-\") + \")|0\",\n              pcube(jperm) + \"=0\")\n  }\n  vars.push(vert(0) + \"=0\", TEMPORARY + \"=0\")\n\n  function forLoopBegin(i, start) {\n    code.push(\"for(\", index(order[i]), \"=\", start, \";\",\n      index(order[i]), \"<\", shape(order[i]), \";\",\n      \"++\", index(order[i]), \"){\")\n  }\n\n  function forLoopEnd(i) {\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[i]), \";\")\n    }\n    code.push(\"}\")\n  }\n\n  function fillEmptySlice(k) {\n    for(var i=k-1; i>=0; --i) {\n      forLoopBegin(i, 0) \n    }\n    var phaseFuncArgs = []\n    for(var i=0; i<arrayArgs; ++i) {\n      if(typesig[i]) {\n        phaseFuncArgs.push(data(i) + \".get(\" + pointer(i) + \")\")\n      } else {\n        phaseFuncArgs.push(data(i) + \"[\" + pointer(i) + \"]\")\n      }\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i))\n    }\n    code.push(PHASES, \"[\", POINTER, \"++]=phase(\", phaseFuncArgs.join(), \");\")\n    for(var i=0; i<k; ++i) {\n      forLoopEnd(i)\n    }\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[k]), \";\")\n    }\n  }\n\n  function processGridCell(mask) {\n    //Read in local data\n    for(var i=0; i<arrayArgs; ++i) {\n      if(typesig[i]) {\n        code.push(cube(i,0), \"=\", data(i), \".get(\", pointer(i), \");\")\n      } else {\n        code.push(cube(i,0), \"=\", data(i), \"[\", pointer(i), \"];\")\n      }\n    }\n\n    //Read in phase\n    var phaseFuncArgs = []\n    for(var i=0; i<arrayArgs; ++i) {\n      phaseFuncArgs.push(cube(i,0))\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i))\n    }\n    \n    code.push(pcube(0), \"=\", PHASES, \"[\", POINTER, \"]=phase(\", phaseFuncArgs.join(), \");\")\n    \n    //Read in other cube data\n    for(var j=1; j<(1<<dimension); ++j) {\n      code.push(pcube(j), \"=\", PHASES, \"[\", POINTER, \"+\", pdelta(j), \"];\")\n    }\n\n    //Check for boundary crossing\n    var vertexPredicate = []\n    for(var j=1; j<(1<<dimension); ++j) {\n      vertexPredicate.push(\"(\" + pcube(0) + \"!==\" + pcube(j) + \")\")\n    }\n    code.push(\"if(\", vertexPredicate.join(\"||\"), \"){\")\n\n    //Read in boundary data\n    var vertexArgs = []\n    for(var i=0; i<dimension; ++i) {\n      vertexArgs.push(index(i))\n    }\n    for(var i=0; i<arrayArgs; ++i) {\n      vertexArgs.push(cube(i,0))\n      for(var j=1; j<(1<<dimension); ++j) {\n        if(typesig[i]) {\n          code.push(cube(i,j), \"=\", data(i), \".get(\", pointer(i), \"+\", delta(i,j), \");\")\n        } else {\n          code.push(cube(i,j), \"=\", data(i), \"[\", pointer(i), \"+\", delta(i,j), \"];\")\n        }\n        vertexArgs.push(cube(i,j))\n      }\n    }\n    for(var i=0; i<(1<<dimension); ++i) {\n      vertexArgs.push(pcube(i))\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      vertexArgs.push(scalar(i))\n    }\n\n    //Generate vertex\n    code.push(\"vertex(\", vertexArgs.join(), \");\",\n      vert(0), \"=\", VERTEX_IDS, \"[\", POINTER, \"]=\", VERTEX_COUNT, \"++;\")\n\n    //Check for face crossings\n    var base = (1<<dimension)-1\n    var corner = pcube(base)\n    for(var j=0; j<dimension; ++j) {\n      if((mask & ~(1<<j))===0) {\n        //Check face\n        var subset = base^(1<<j)\n        var edge = pcube(subset)\n        var faceArgs = [ ]\n        for(var k=subset; k>0; k=(k-1)&subset) {\n          faceArgs.push(VERTEX_IDS + \"[\" + POINTER + \"+\" + pdelta(k) + \"]\")\n        }\n        faceArgs.push(vert(0))\n        for(var k=0; k<arrayArgs; ++k) {\n          if(j&1) {\n            faceArgs.push(cube(k,base), cube(k,subset))\n          } else {\n            faceArgs.push(cube(k,subset), cube(k,base))\n          }\n        }\n        if(j&1) {\n          faceArgs.push(corner, edge)\n        } else {\n          faceArgs.push(edge, corner)\n        }\n        for(var k=0; k<scalarArgs; ++k) {\n          faceArgs.push(scalar(k))\n        }\n        code.push(\"if(\", corner, \"!==\", edge, \"){\",\n          \"face(\", faceArgs.join(), \")}\")\n      }\n    }\n    \n    //Increment pointer, close off if statement\n    code.push(\"}\",\n      POINTER, \"+=1;\")\n  }\n\n  function flip() {\n    for(var j=1; j<(1<<dimension); ++j) {\n      code.push(TEMPORARY, \"=\", pdelta(j), \";\",\n                pdelta(j), \"=\", qcube(j), \";\",\n                qcube(j), \"=\", TEMPORARY, \";\")\n    }\n  }\n\n  function createLoop(i, mask) {\n    if(i < 0) {\n      processGridCell(mask)\n      return\n    }\n    fillEmptySlice(i)\n    code.push(\"if(\", shape(order[i]), \">0){\",\n      index(order[i]), \"=1;\")\n    createLoop(i-1, mask|(1<<order[i]))\n\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[i]), \";\")\n    }\n    if(i === dimension-1) {\n      code.push(POINTER, \"=0;\")\n      flip()\n    }\n    forLoopBegin(i, 2)\n    createLoop(i-1, mask)\n    if(i === dimension-1) {\n      code.push(\"if(\", index(order[dimension-1]), \"&1){\",\n        POINTER, \"=0;}\")\n      flip()\n    }\n    forLoopEnd(i)\n    code.push(\"}\")\n  }\n\n  createLoop(dimension-1, 0)\n\n  //Release scratch memory\n  code.push(\"freeUint32(\", VERTEX_IDS, \");freeUint32(\", PHASES, \");\")\n\n  //Compile and link procedure\n  var procedureCode = [\n    \"'use strict';\",\n    \"function \", funcName, \"(\", args.join(), \"){\",\n      \"var \", vars.join(), \";\",\n      code.join(\"\"),\n    \"}\",\n    \"return \", funcName ].join(\"\")\n\n  var proc = new Function(\n    \"vertex\", \n    \"face\", \n    \"phase\", \n    \"mallocUint32\", \n    \"freeUint32\",\n    procedureCode)\n  return proc(\n    vertexFunc, \n    faceFunc, \n    phaseFunc, \n    pool.mallocUint32, \n    pool.freeUint32)\n}\n\nfunction createSurfaceExtractor(args) {\n  function error(msg) {\n    throw new Error(\"ndarray-extract-contour: \" + msg)\n  }\n  if(typeof args !== \"object\") {\n    error(\"Must specify arguments\")\n  }\n  var order = args.order\n  if(!Array.isArray(order)) {\n    error(\"Must specify order\")\n  }\n  var arrays = args.arrayArguments||1\n  if(arrays < 1) {\n    error(\"Must have at least one array argument\")\n  }\n  var scalars = args.scalarArguments||0\n  if(scalars < 0) {\n    error(\"Scalar arg count must be > 0\")\n  }\n  if(typeof args.vertex !== \"function\") {\n    error(\"Must specify vertex creation function\")\n  }\n  if(typeof args.cell !== \"function\") {\n    error(\"Must specify cell creation function\")\n  }\n  if(typeof args.phase !== \"function\") {\n    error(\"Must specify phase function\")\n  }\n  var getters = args.getters || []\n  var typesig = new Array(arrays)\n  for(var i=0; i<arrays; ++i) {\n    if(getters.indexOf(i) >= 0) {\n      typesig[i] = true\n    } else {\n      typesig[i] = false\n    }\n  }\n  return compileSurfaceProcedure(\n    args.vertex,\n    args.cell,\n    args.phase,\n    scalars,\n    order,\n    typesig)\n}"]},"metadata":{},"sourceType":"script"}