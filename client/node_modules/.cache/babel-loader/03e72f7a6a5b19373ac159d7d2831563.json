{"ast":null,"code":"'use strict';\n\nvar readUInt = require('../readUInt'); // NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\n\n\nfunction isJPG(buffer) {\n  //, filepath\n  var SOIMarker = buffer.toString('hex', 0, 2);\n  return 'ffd8' === SOIMarker;\n}\n\nfunction isEXIF(buffer) {\n  //, filepath\n  var exifMarker = buffer.toString('hex', 2, 6);\n  return exifMarker === '45786966'; // 'Exif'\n}\n\nfunction extractSize(buffer, i) {\n  return {\n    'height': buffer.readUInt16BE(i),\n    'width': buffer.readUInt16BE(i + 2)\n  };\n}\n\nvar APP1_DATA_SIZE_BYTES = 2;\nvar EXIF_HEADER_BYTES = 6;\nvar TIFF_BYTE_ALIGN_BYTES = 2;\nvar BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nvar LITTLE_ENDIAN_BYTE_ALIGN = '4949'; // Each entry is exactly 12 bytes\n\nvar IDF_ENTRY_BYTES = 12;\nvar NUM_DIRECTORY_ENTRIES_BYTES = 2;\n\nfunction validateExifBlock(buffer, i) {\n  // Skip APP1 Data Size\n  var exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, i); // Consider byte alignment\n\n  var byteAlign = exifBlock.toString('hex', EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES); // Ignore Empty EXIF. Validate byte alignment\n\n  var isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n  var isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n\n  if (isBigEndian || isLittleEndian) {\n    return extractOrientation(exifBlock, isBigEndian);\n  }\n}\n\nfunction extractOrientation(exifBlock, isBigEndian) {\n  // TODO: assert that this contains 0x002A\n  // var STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2;\n  // var TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4;\n  // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n  var idfOffset = 8; // IDF osset works from right after the header bytes\n  // (so the offset includes the tiff byte align)\n\n  var offset = EXIF_HEADER_BYTES + idfOffset;\n  var idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);\n  var start;\n  var end;\n\n  for (var directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n    start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;\n    end = start + IDF_ENTRY_BYTES; // Skip on corrupt EXIF blocks\n\n    if (start > exifBlock.length) {\n      return;\n    }\n\n    var block = exifBlock.slice(start, end);\n    var tagNumber = readUInt(block, 16, 0, isBigEndian); // 0x0112 (decimal: 274) is the `orientation` tag ID\n\n    if (tagNumber === 274) {\n      var dataFormat = readUInt(block, 16, 2, isBigEndian);\n\n      if (dataFormat !== 3) {\n        return;\n      } // unsinged int has 2 bytes per component\n      // if there would more than 4 bytes in total it's a pointer\n\n\n      var numberOfComponents = readUInt(block, 32, 4, isBigEndian);\n\n      if (numberOfComponents !== 1) {\n        return;\n      }\n\n      return readUInt(block, 16, 8, isBigEndian);\n    }\n  }\n}\n\nfunction validateBuffer(buffer, i) {\n  // index should be within buffer limits\n  if (i > buffer.length) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  } // Every JPEG block must begin with a 0xFF\n\n\n  if (buffer[i] !== 0xFF) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n}\n\nfunction calculate(buffer) {\n  // Skip 4 chars, they are for signature\n  buffer = buffer.slice(4);\n  var orientation;\n  var i, next;\n\n  while (buffer.length) {\n    // read length of the next block\n    i = buffer.readUInt16BE(0);\n\n    if (isEXIF(buffer)) {\n      orientation = validateExifBlock(buffer, i);\n    } // ensure correct format\n\n\n    validateBuffer(buffer, i); // 0xFFC0 is baseline standard(SOF)\n    // 0xFFC1 is baseline optimized(SOF)\n    // 0xFFC2 is progressive(SOF2)\n\n    next = buffer[i + 1];\n\n    if (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n      var size = extractSize(buffer, i + 5);\n\n      if (!orientation) {\n        return size;\n      }\n\n      return {\n        width: size.width,\n        height: size.height,\n        orientation: orientation\n      };\n    } // move to the next block\n\n\n    buffer = buffer.slice(i + 2);\n  }\n\n  throw new TypeError('Invalid JPG, no size found');\n}\n\nmodule.exports = {\n  'detect': isJPG,\n  'calculate': calculate\n};","map":{"version":3,"sources":["/Users/caseyrudick/Documents/landsharkrefactored-copy/client/node_modules/image-size/lib/types/jpg.js"],"names":["readUInt","require","isJPG","buffer","SOIMarker","toString","isEXIF","exifMarker","extractSize","i","readUInt16BE","APP1_DATA_SIZE_BYTES","EXIF_HEADER_BYTES","TIFF_BYTE_ALIGN_BYTES","BIG_ENDIAN_BYTE_ALIGN","LITTLE_ENDIAN_BYTE_ALIGN","IDF_ENTRY_BYTES","NUM_DIRECTORY_ENTRIES_BYTES","validateExifBlock","exifBlock","slice","byteAlign","isBigEndian","isLittleEndian","extractOrientation","idfOffset","offset","idfDirectoryEntries","start","end","directoryEntryNumber","length","block","tagNumber","dataFormat","numberOfComponents","validateBuffer","TypeError","calculate","orientation","next","size","width","height","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar readUInt = require('../readUInt');\n\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\n\nfunction isJPG (buffer) { //, filepath\n  var SOIMarker = buffer.toString('hex', 0, 2);\n  return ('ffd8' === SOIMarker);\n}\n\nfunction isEXIF (buffer) { //, filepath\n  var exifMarker = buffer.toString('hex', 2, 6);\n  return (exifMarker === '45786966'); // 'Exif'\n}\n\nfunction extractSize (buffer, i) {\n  return {\n    'height' : buffer.readUInt16BE(i),\n    'width' : buffer.readUInt16BE(i + 2)\n  };\n}\n\nvar APP1_DATA_SIZE_BYTES = 2;\nvar EXIF_HEADER_BYTES = 6;\nvar TIFF_BYTE_ALIGN_BYTES = 2;\nvar BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nvar LITTLE_ENDIAN_BYTE_ALIGN = '4949';\n\n// Each entry is exactly 12 bytes\nvar IDF_ENTRY_BYTES = 12;\nvar NUM_DIRECTORY_ENTRIES_BYTES = 2;\n\nfunction validateExifBlock (buffer, i) {\n  // Skip APP1 Data Size\n  var exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, i);\n\n  // Consider byte alignment\n  var byteAlign = exifBlock.toString('hex', EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n\n  // Ignore Empty EXIF. Validate byte alignment\n  var isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n  var isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n\n  if (isBigEndian || isLittleEndian) {\n    return extractOrientation(exifBlock, isBigEndian);\n  }\n}\n\nfunction extractOrientation (exifBlock, isBigEndian) {\n  // TODO: assert that this contains 0x002A\n  // var STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2;\n  // var TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4;\n\n  // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n  var idfOffset = 8;\n\n  // IDF osset works from right after the header bytes\n  // (so the offset includes the tiff byte align)\n  var offset = EXIF_HEADER_BYTES + idfOffset;\n\n  var idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);\n\n  var start;\n  var end;\n  for (var directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n    start = offset + NUM_DIRECTORY_ENTRIES_BYTES + (directoryEntryNumber * IDF_ENTRY_BYTES);\n    end = start + IDF_ENTRY_BYTES;\n\n    // Skip on corrupt EXIF blocks\n    if (start > exifBlock.length) {\n      return;\n    }\n\n    var block = exifBlock.slice(start, end);\n    var tagNumber = readUInt(block, 16, 0, isBigEndian);\n\n    // 0x0112 (decimal: 274) is the `orientation` tag ID\n    if (tagNumber === 274) {\n      var dataFormat = readUInt(block, 16, 2, isBigEndian);\n      if (dataFormat !== 3) {\n        return;\n      }\n\n      // unsinged int has 2 bytes per component\n      // if there would more than 4 bytes in total it's a pointer\n      var numberOfComponents = readUInt(block, 32, 4, isBigEndian);\n      if (numberOfComponents !== 1) {\n        return;\n      }\n\n      return readUInt(block, 16, 8, isBigEndian);\n    }\n  }\n}\n\nfunction validateBuffer (buffer, i) {\n  // index should be within buffer limits\n  if (i > buffer.length) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  }\n  // Every JPEG block must begin with a 0xFF\n  if (buffer[i] !== 0xFF) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n}\n\nfunction calculate (buffer) {\n  // Skip 4 chars, they are for signature\n  buffer = buffer.slice(4);\n\n  var orientation;\n\n  var i, next;\n  while (buffer.length) {\n    // read length of the next block\n    i = buffer.readUInt16BE(0);\n\n    if (isEXIF(buffer)) {\n      orientation = validateExifBlock(buffer, i);\n    }\n\n    // ensure correct format\n    validateBuffer(buffer, i);\n\n    // 0xFFC0 is baseline standard(SOF)\n    // 0xFFC1 is baseline optimized(SOF)\n    // 0xFFC2 is progressive(SOF2)\n    next = buffer[i + 1];\n    if (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n      var size = extractSize(buffer, i + 5);\n\n      if (!orientation) {\n        return size;\n      }\n\n      return {\n        width: size.width,\n        height: size.height,\n        orientation: orientation\n      };\n    }\n\n    // move to the next block\n    buffer = buffer.slice(i + 2);\n  }\n\n  throw new TypeError('Invalid JPG, no size found');\n}\n\nmodule.exports = {\n  'detect': isJPG,\n  'calculate': calculate\n};\n"]},"metadata":{},"sourceType":"script"}