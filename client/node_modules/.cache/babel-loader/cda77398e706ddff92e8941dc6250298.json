{"ast":null,"code":"import EW from'./EW';import NS from'./NS';export default(function(measuredDepthCurrent,inclinationCurrent,azimuthCurrent){var measuredDepthPrior=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var inclinationPrior=arguments.length>4&&arguments[4]!==undefined?arguments[4]:2;var azimuthPrior=arguments.length>5&&arguments[5]!==undefined?arguments[5]:3;var calculatedNorthingPrior=arguments.length>6&&arguments[6]!==undefined?arguments[6]:0.02;var calculatedEastingPrior=arguments.length>7&&arguments[7]!==undefined?arguments[7]:0;var index=arguments.length>8?arguments[8]:undefined;var vsDirection=arguments.length>9&&arguments[9]!==undefined?arguments[9]:0;var converter=Math.PI/180;var converter2=0.00000001;var calculatedEastingCurrent=EW(measuredDepthCurrent,inclinationCurrent,azimuthCurrent,measuredDepthPrior,inclinationPrior,azimuthPrior,calculatedEastingPrior);var calculatedNorthingCurrent=NS(measuredDepthCurrent,inclinationCurrent,azimuthCurrent,measuredDepthPrior,inclinationPrior,azimuthPrior,calculatedNorthingPrior);var closure=Math.atan2(calculatedEastingCurrent,calculatedNorthingCurrent+converter2)/converter;var determineClosure=function determineClosure(){if(closure<0){return Math.cos((360+closure-vsDirection)*converter);}else{return Math.cos((closure-vsDirection)*converter);}};var HD=Math.sqrt(Math.pow(calculatedNorthingCurrent,2)+Math.pow(calculatedEastingCurrent,2));var calculatedSect=HD*determineClosure();return parseFloat(calculatedSect.toFixed(2));});","map":{"version":3,"sources":["/Users/caseyrudick/Documents/Work/landsharkfinal/landSharkRefactored/client/src/HelperFunctions/Calculations/SECT.js"],"names":["EW","NS","measuredDepthCurrent","inclinationCurrent","azimuthCurrent","measuredDepthPrior","inclinationPrior","azimuthPrior","calculatedNorthingPrior","calculatedEastingPrior","index","vsDirection","converter","Math","PI","converter2","calculatedEastingCurrent","calculatedNorthingCurrent","closure","atan2","determineClosure","cos","HD","sqrt","pow","calculatedSect","parseFloat","toFixed"],"mappings":"AAAA,MAAOA,CAAAA,EAAP,KAAe,MAAf,CACA,MAAOC,CAAAA,EAAP,KAAe,MAAf,CAEA,eAAe,SAACC,oBAAD,CAAuBC,kBAAvB,CAA2CC,cAA3C,CAAkN,IAAvJC,CAAAA,kBAAuJ,2DAAlI,CAAkI,IAA/HC,CAAAA,gBAA+H,2DAA5G,CAA4G,IAAzGC,CAAAA,YAAyG,2DAA1F,CAA0F,IAAvFC,CAAAA,uBAAuF,2DAA7D,IAA6D,IAAvDC,CAAAA,sBAAuD,2DAA9B,CAA8B,IAA3BC,CAAAA,KAA2B,8CAApBC,CAAAA,WAAoB,2DAAN,CAAM,CAC/N,GAAMC,CAAAA,SAAS,CAAIC,IAAI,CAACC,EAAN,CAAU,GAA5B,CACA,GAAMC,CAAAA,UAAU,CAAG,UAAnB,CAEA,GAAMC,CAAAA,wBAAwB,CAAGhB,EAAE,CAACE,oBAAD,CAAuBC,kBAAvB,CAA2CC,cAA3C,CAA2DC,kBAA3D,CAA+EC,gBAA/E,CAAiGC,YAAjG,CAA+GE,sBAA/G,CAAnC,CAEA,GAAMQ,CAAAA,yBAAyB,CAAGhB,EAAE,CAACC,oBAAD,CAAuBC,kBAAvB,CAA2CC,cAA3C,CAA2DC,kBAA3D,CAA+EC,gBAA/E,CAAiGC,YAAjG,CAA+GC,uBAA/G,CAApC,CAEA,GAAMU,CAAAA,OAAO,CAAGL,IAAI,CAACM,KAAL,CAAWH,wBAAX,CAAqCC,yBAAyB,CAAGF,UAAjE,EAA+EH,SAA/F,CAEA,GAAMQ,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,EAAM,CAC7B,GAAIF,OAAO,CAAG,CAAd,CAAiB,CACf,MAAOL,CAAAA,IAAI,CAACQ,GAAL,CAAS,CAAE,IAAMH,OAAP,CAAkBP,WAAnB,EAAkCC,SAA3C,CAAP,CACD,CAFD,IAEO,CACL,MAAOC,CAAAA,IAAI,CAACQ,GAAL,CAAS,CAACH,OAAO,CAAGP,WAAX,EAA0BC,SAAnC,CAAP,CACD,CACF,CAND,CAQA,GAAMU,CAAAA,EAAE,CAAGT,IAAI,CAACU,IAAL,CAAUV,IAAI,CAACW,GAAL,CAASP,yBAAT,CAAoC,CAApC,EAAyCJ,IAAI,CAACW,GAAL,CAASR,wBAAT,CAAmC,CAAnC,CAAnD,CAAX,CAEA,GAAMS,CAAAA,cAAc,CAAGH,EAAE,CAAGF,gBAAgB,EAA5C,CAGA,MACEM,CAAAA,UAAU,CAACD,cAAc,CAACE,OAAf,CAAuB,CAAvB,CAAD,CADZ,CAGD,CA1BD","sourcesContent":["import EW from './EW';\nimport NS from './NS';\n\nexport default (measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior = 1, inclinationPrior = 2, azimuthPrior = 3, calculatedNorthingPrior = 0.02, calculatedEastingPrior = 0, index, vsDirection = 0) => {\n  const converter = (Math.PI)/180;\n  const converter2 = 0.00000001;\n\n  const calculatedEastingCurrent = EW(measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior, inclinationPrior, azimuthPrior, calculatedEastingPrior)\n\n  const calculatedNorthingCurrent = NS(measuredDepthCurrent, inclinationCurrent, azimuthCurrent, measuredDepthPrior, inclinationPrior, azimuthPrior, calculatedNorthingPrior)\n\n  const closure = Math.atan2(calculatedEastingCurrent, calculatedNorthingCurrent + converter2) / converter\n\n  const determineClosure = () => {\n    if (closure < 0) {\n      return Math.cos(((360 + closure) - vsDirection) * converter)\n    } else {\n      return Math.cos((closure - vsDirection) * converter)\n    }\n  }\n\n  const HD = Math.sqrt(Math.pow(calculatedNorthingCurrent, 2) + Math.pow(calculatedEastingCurrent, 2))\n\n  const calculatedSect = HD * determineClosure()\n\n\n  return (\n    parseFloat(calculatedSect.toFixed(2))\n  )\n};\n"]},"metadata":{},"sourceType":"module"}